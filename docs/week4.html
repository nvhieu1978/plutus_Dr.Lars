<h1 id="week-04-monads">Week 04 - Monads</h1>
<p>::: {.note}
::: {.title}
Note
:::</p>
<p>Đây là phiên bản viết của Bài <a href="https://youtu.be/HLJOcKlEucI">giảng số
4</a>.</p>
<p>Trong bài giảng này, chúng ta tìm hiểu về Đơn nguyên. Đặc biệt là các
monads EmulatorTrace và Contract..
:::</p>
<p>Tổng quat --------</p>
<p>Chúng tôi đã dành hai bài giảng cuối cùng để nói về phần on-chain của
Plutus - logic xác thực được biên dịch thành tập lệnh Plutus và thực sự
sống trên blockchain và được thực hiện bởi các nút xác thực giao dịch.</p>
<p>Còn rất nhiều điều để nói về bộ phận on-chain đó.</p>
<p>Chúng tôi chưa xem xét các ví dụ phức tạp hơn về xác thực sử dụng ngữ
cảnh phức tạp hơn và chúng tôi chưa thấy cách mã thông báo gốc hoạt động
như thế nào (tập lệnh Plutus cũng được sử dụng để xác thực việc đúc và
đốt mã thông báo gốc).</p>
<p>Chúng ta chắc chắn sẽ phải nói về những chủ đề đó, và quay lại vấn đề
đó.</p>
<p>Tuy nhiên, trước khi đi vào quá nhiều chủ đề phức tạp về xác thực trên
chuỗi, chúng ta không được bỏ qua phần ngoài chuỗi, vì nó cũng quan
trọng không kém.</p>
<p>Phần on-chain đảm nhận việc xác thực nhưng để có thứ gì đó được xác
thực, chúng ta phải xây dựng một giao dịch và gửi nó lên blockchain. Và,
đó là những gì phần off-chain thực hiện.</p>
<p>Vì vậy, chúng ta sẽ bắt đầu nói về cách viết mã Plutus ngoài chuỗi.</p>
<p>Thật không may, có một vấn đề nhỏ liên quan đến các tính năng Haskell
cần thiết.</p>
<p>Phần on-chain mà chúng ta đã thấy cho đến nay hơi xa lạ và cần làm quen
một chút, do thực tế là chúng ta có thêm sự phức tạp của quá trình biên
dịch sang tập lệnh Plutus. Nhưng, chúng ta không thực sự phải lo lắng về
điều đó nếu chúng ta sử dụng phép thuật Template Haskell. Trong trường
hợp đó, hàm xác nhận chỉ là một hàm đơn giản.</p>
<p>Và nó thực sự là một hàm Haskell rất đơn giản theo quan điểm kỹ thuật.
Chúng tôi không sử dụng bất kỳ tính năng Haskell ưa thích nào để viết
hàm này.</p>
<p>Một trong những lý do cho điều đó là cách thức hoạt động của quá trình
biên dịch Plutus. Chúng tôi đã thấy làm thế nào để việc biên dịch sang
Plutus thành công, tất cả mã được sử dụng bởi hàm xác nhận phải có sẵn
trong Oxford Brackets. Điều này có nghĩa là tất cả các chức năng được sử
dụng bởi chức năng <em>mkValidator</em> phải sử dụng pragma INLINABLE.</p>
<pre><code class="lang-{.haskell}">{-# INLINABLE mkValidator #-}
mkValidator :: Data -&gt; Data -&gt; Data -&gt; ()
mkValidator <span class="hljs-keyword">_</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">_</span> = ()

$$(PlutusTx.compile [|<span class="hljs-type">| mkValidator</span> |<span class="hljs-type">|])</span>
</code></pre>
<p>Và hãy nhớ lại rằng vì các hàm Haskell tiêu chuẩn không có pragma CÓ THỂ
LỆNH này, nên có một mô-đun Plutus Prelude mới tương tự như Haskell
Prelude tiêu chuẩn, nhưng với các chức năng được xác định với pragma
INLINABLE.</p>
<p>Nhưng, tất nhiên, có hàng trăm thư viện Haskell ngoài kia và hầu hết
chúng không được viết với Plutus, vì vậy chúng tôi không thể sử dụng
chúng trong quá trình xác thực. Và, điều đó có tác dụng là xác thực bên
trong Haskell sẽ tương đối đơn giản và sẽ không có nhiều phụ thuộc.</p>
<h2 id="monads">Monads</h2>
<p>Trong phần off-chain của Plutus, tình hình đã đảo ngược. Chúng ta không
phải lo lắng về việc biên dịch sang tập lệnh Plutus - nó chỉ là Haskell
đơn giản. Tuy nhiên, mặt trái của nó là, cách nó được thực hiện, nó sử
dụng các tính năng Haskell phức tạp hơn nhiều - ví dụ như cái gọi là hệ
thống hiệu ứng, phát trực tuyến và đặc biệt là monads.</p>
<p>Tất cả mã off-chain (mã ví), được viết bằng một đơn nguyên đặc biệt -
Đơn nguyên hợp đồng.</p>
<p>Các tu viện nổi tiếng trong thế giới Haskell. Đây thường là trở ngại đầu
tiên khi bắt đầu lập trình viên Haskell.</p>
<p>Có rất nhiều hướng dẫn cố gắng giải thích các Monads. Monads được so
sánh với burritos, và tất cả các loại ẩn dụ được sử dụng để cố gắng giải
thích khái niệm. Nhưng ở đây, ít nhất chúng ta hãy cố gắng cung cấp một
khóa học cơ bản về monads cho những người mới sử dụng Haskell.</p>
<p>Trước khi đến với các đơn nguyên chung, chúng ta sẽ bắt đầu với IO , đó
là cách xử lý các tác dụng phụ của IO trong Haskell. Tuy nhiên, trước
khi đến với Haskell, chúng ta hãy xem xét một ngôn ngữ chính thống như
Java.</p>
<p>Hãy xem xét phương pháp Java sau đây.</p>
<pre><code class="lang-{.java}"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
   ...
}
</code></pre>
<p>Hàm này không có đối số và nó trả về <code>int</code>. Hãy tưởng tượng nó được gọi
hai lần trong mã.</p>
<pre><code class="lang-{.java}">...
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = foo();
...
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> b = foo();
</code></pre>
<p>Bây giờ, chúng ta lưu ý rằng, chừng nào chúng ta không biết điều gì đang
xảy ra bên trong hàm foo(), thì giá trị trả về của biểu thức sau là
không xác định.</p>
<pre><code class="lang-{.java}">a == b; // <span class="hljs-literal">true</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">false</span>? <span class="hljs-built_in">at</span> <span class="hljs-built_in">compile</span> <span class="hljs-built_in">time</span>, we don't know
</code></pre>
<p>Chúng tôi không biết có <code>a</code> giống như <code>b</code> vậy không vì trong Java, hoàn
toàn có thể xảy ra một số IO bên trong <code>foo</code>. Ví dụ: có mã là mã yêu cầu
người dùng nhập đầu vào trên bảng điều khiển và sử dụng mã này để tính
toán giá trị trả về.</p>
<p>Điều này có nghĩa là, để lập luận về mã, chúng ta cần phải nhìn vào bên
trong <code>foo</code>, điều này làm cho việc thử nghiệm trở nên khó khăn hơn. Và
nó có nghĩa là, <code>foo</code> ví dụ , đó là lệnh gọi trả về đầu tiên <code>13</code>- chúng
ta không thể thay thế tất cả các lệnh gọi khác đến <code>foo</code> bằng giá trị
trả về đã biết của <code>13</code>.</p>
<p>Ở Haskell, tình hình rất khác vì Haskell là một ngôn ngữ chức năng thuần
túy. Chữ ký tương đương trong Haskell sẽ giống như sau:</p>
<pre><code class="lang-{.haskell}">foo :: Int
foo = ...
</code></pre>
<p>Bây giờ, nếu chúng ta gặp trường hợp chúng ta gọi <code>foo</code> hai lần, mặc dù
chúng ta không biết giá trị của <code>foo</code> là gì, chúng ta biết chắc rằng hai
giá trị trả về sẽ giống nhau.</p>
<p>Đây là một tính năng rất quan trọng được gọi là tính minh bạch tham
chiếu . Trên thực tế, có một số cửa thoát hiểm để giải quyết vấn đề này,
nhưng chúng ta có thể bỏ qua điều này.</p>
<p>Điều này làm cho các tác vụ như tái cấu trúc và kiểm tra dễ dàng hơn
nhiều.</p>
<p>Điều này là rất tốt, nhưng bạn cần có tác dụng phụ để có ảnh hưởng đến
thế giới. Nếu không, tất cả những gì chương trình của bạn làm là làm
nóng bộ xử lý.</p>
<p>Bạn cần đầu vào và đầu ra. Bạn phải có khả năng ghi kết quả đầu ra ra
màn hình, hoặc đọc đầu vào từ bàn phím, kết nối mạng hoặc tệp, chẳng
hạn.</p>
<p>Có một <a href="https://www.youtube.com/watch?v=iSmkqocn0oQ">video nổi tiếng của Simon Peyton-Jones là Haskell Is
Useless</a> giải thích rằng
ngôn ngữ thuần túy, không có tác dụng phụ thì rất đẹp về mặt toán học,
nhưng cuối cùng thì bạn cũng cần có tác dụng phụ để biến bất cứ điều gì
xảy ra.</p>
<p>Và Haskell có một cách để xử lý các tác dụng phụ và đó là Đơn nguyên IO.
Tuy nhiên, đừng lo lắng về phần đơn nguyên.</p>
<p>Đây là cách chúng tôi làm điều đó trong Haskell.</p>
<pre><code class="lang-{.haskell}">foo <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> <span class="hljs-built_in">Int</span>
foo = ...
</code></pre>
<p><em>IO</em> là một phương thức khởi tạo kiểu nhận một đối số, giống như một số
ví dụ khác về các hàm tạo kiểu như <em>Maybe</em> and <em>List</em> . Tuy nhiên, không
giống như những ví dụ đó, <em>IO</em> đặc biệt, theo nghĩa là bạn không thể
triển khai nó bằng chính ngôn ngữ. Nó là một nguyên thủy được tích hợp
sẵn.</p>
<p>Giá trị trả về <em>IO Int</em> cho chúng ta biết rằng đây là một công thức để
tính Int và công thức này có thể gây ra các phản ứng phụ. Một danh sách
các hướng dẫn cho máy tính biết phải làm gì để kết thúc với một <em>Int</em> .</p>
<p>Điều quan trọng cần lưu ý là tính minh bạch của tham chiếu không bị phá
vỡ ở đây. Kết quả đánh giá foo là chính công thức, không phải giá trị
<em>Int</em> . Và vì công thức luôn giống nhau, nên tính minh bạch của tham
chiếu được duy trì.</p>
<p>Cách duy nhất để thực sự thực hiện một công thức như vậy trong chương
trình Haskell là từ điểm nhập chính của chương trình - hàm chính . Bạn
cũng có thể thực hiện các hành động IO trong REPL.</p>
<h3 id="hello-world">Hello World</h3>
<p>Hello World in Haskell trông như thế này:</p>
<pre><code class="lang-{.haskell}">main <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> ()
main = putStrLn <span class="hljs-string">"Hello, world!"</span>
</code></pre>
<p>Ở đây, <em>main</em> là một công thức thực hiện một số tác dụng phụ và trả về
Đơn vị - không có gì đáng quan tâm.</p>
<p>Hãy xem <em>putStrLn</em> trong REPL. Chúng tôi thấy rằng đó là một hành động
IO sử dụng <em>String</em> và không trả về kết quả thú vị nào.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; :t putStrLn
putStrLn <span class="hljs-type">::</span> <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">IO</span> ()

Prelude Week04.Contract&gt; :t putStrLn <span class="hljs-string">"Hello, world!"</span>
putStrLn <span class="hljs-string">"Hello, world!"</span> <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> ()
</code></pre>
<p>Chúng tôi cũng có thể chạy điều này. Mở ứng dụng / tệp Main.sh và chỉnh
sửa chức năng chính để nó đọc:</p>
<pre><code class="lang-{.haskell}">main <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> ()
main = putStrLn <span class="hljs-string">"Hello, world!"</span>
</code></pre>
<p>Sau đó chạy</p>
<pre><code class="lang-{.bash}">cabal <span class="hljs-keyword">run</span><span class="bash"> hello</span>
</code></pre>
<p>Chúng ta sẽ xem xét nhanh tệp cabal ngay bây giờ.</p>
<p>Trong các bài giảng trước, chúng ta chỉ cần phần thư viện <em>library</em>
trong tệp <em>plutus-pioneer-program-week04.cabal</em> vì chúng ta chỉ xử lý
các hàm thư viện. Bây giờ, chúng ta cần thêm một khổ thơ có thể thực thi
được .</p>
<pre><code class="lang-{.cabal}"><span class="hljs-built_in">executable</span> hello
hs-<span class="hljs-keyword">source</span>-dir<span class="hljs-variable">s:</span>      app
main-i<span class="hljs-variable">s:</span>             hello.hs
build-depend<span class="hljs-variable">s:</span>       base ^&gt;=<span class="hljs-number">4.14</span>.<span class="hljs-number">1.0</span>
default-<span class="hljs-keyword">language</span>:    Haskell2010
ghc-option<span class="hljs-variable">s:</span>         -Wall -O2
</code></pre>
<p>Điều này chỉ định thư mục nguồn và tệp nào giữ chức năng chính. Thông
thường tên tệp phải khớp với tên mô-đun, nhưng <em>main</em> là một ngoại lệ.</p>
<p>Thay vì chỉ yêu cầu loại <em>putStrLn</em> , chúng ta có thể chạy nó trong
REPL. Như đã đề cập, REPL cho phép chúng ta thực hiện các hành động IO.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; putStrLn <span class="hljs-string">"Hello, world!"</span>
Hello, world!
</code></pre>
<h3 id="getline">getLine</h3>
<p>Hãy xem <em>getLine</em></p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; :t getLine
getLine <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> <span class="hljs-built_in">String</span>
</code></pre>
<p>Điều này cho thấy rằng đó là một công thức, có thể tạo ra các hiệu ứng
phụ, khi được thực thi sẽ tạo ra một Chuỗi . Trong trường hợp getLine ,
tác dụng phụ được đề cập là nó sẽ đợi người dùng nhập từ bàn phím.</p>
<p>Nếu chúng ta thực thi getLine trong REPL.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-selector-tag">Prelude</span> <span class="hljs-selector-tag">Week04</span><span class="hljs-selector-class">.Contract</span>&gt; <span class="hljs-selector-tag">getLine</span>
</code></pre>
<p>Nó chờ nhập bàn phím. Sau đó, nếu chúng ta nhập một cái gì đó, nó sẽ trả
về kết quả.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-attribute">Haskell</span>
<span class="hljs-string">"Haskell"</span>
</code></pre>
<p>Có một loạt các hành động IO được định nghĩa trong Haskell để thực hiện
tất cả các loại như đọc tệp, ghi tệp, đọc từ và ghi vào ổ cắm.</p>
<p>Nhưng cho dù bạn có bao nhiêu hành động được xác định trước, điều đó sẽ
không bao giờ là đủ để đạt được điều gì đó phức tạp, vì vậy cần phải có
cách để kết hợp các hành động IO nguyên thủy này thành những công thức
lớn hơn, phức tạp hơn.</p>
<p>Một điều chúng ta có thể làm là sử dụng phiên bản kiểu <em>Functor</em> của IO.
Hãy xem xét các trường hợp loại của <em>IO</em> trong REPL.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt;<span class="hljs-keyword"> :i</span> IO
type IO<span class="hljs-keyword"> :</span>: * -&gt; *
newtype IO a
= ghc-prim-0.6.1:GHC.Types.IO (ghc-prim-0.6.1:GHC.Prim.State<span class="hljs-comment">#</span>
                                 ghc-prim-0.6.1:GHC.Prim.RealWorld
                                 -&gt; (<span class="hljs-comment"># ghc-prim-0.6.1:GHC.Prim.State#</span>
                                       ghc-prim-0.6.1:GHC.Prim.RealWorld,
                                       a <span class="hljs-comment">#))</span>
   -- Defined in ‘ghc-prim-0.6.1:GHC.Types’<span class="hljs-built_in">
instance </span>Applicative IO -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor IO -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monad IO -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monoid a =&gt; Monoid (IO a) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Semigroup a =&gt; Semigroup (IO a) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>MonadFail IO -- Defined in ‘Control.Monad.Fail’
</code></pre>
<p>Chúng ta thấy cá thể <em>Monad</em> đáng sợ , nhưng chúng ta cũng thấy một cá
thể <em>Functor</em>. <em>Functor</em> là một loại lớp rất quan trọng trong Haskell.
Nếu chúng ta nhìn vào nó trong REPL:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt;<span class="hljs-keyword"> :i</span> Functor
type Functor<span class="hljs-keyword"> :</span>: (* -&gt; *) -&gt; Constraint
class Functor f where
fmap<span class="hljs-keyword"> :</span>: (a -&gt; b) -&gt; f a -&gt; f b
(&lt;$)<span class="hljs-keyword"> :</span>: a -&gt; f b -&gt; f a
{-<span class="hljs-comment"># MINIMAL fmap #-}</span>
   -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor (Either a) -- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>Functor [] -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor Maybe -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor IO -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor ((-&gt;) r) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor ((,,,) a b c) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor ((,,) a b) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor ((,) a) -- Defined in ‘GHC.Base’
</code></pre>
<p>Phương pháp quan trọng ở đây là fmap . Hàm thứ hai (\&lt;\$) là một hàm
tiện lợi.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">fmap</span> :: (a -&gt;</span> <span class="hljs-function"><span class="hljs-title">b</span>) -&gt;</span> <span class="hljs-function"><span class="hljs-title">f</span> a -&gt;</span> f b
</code></pre>
<p>Hàm này <em>fmap</em> , mà tất cả <em>Functor</em>s có cho chúng ta biết rằng, nếu
chúng ta cấp cho nó quyền truy cập vào một hàm có thể biến <em>a</em> thàng <em>b</em>
, thì nó có thể biến fa thành fb cho chúng ta. Ở đây, chúng ta quan tâm
đến trường hợp f là IO .</p>
<p>Nếu chúng ta chuyên biệt hóa hàm cho <em>IO</em> , chúng ta sẽ có một hàm như:</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">fmap</span>' :: (a -&gt;</span> <span class="hljs-function"><span class="hljs-title">b</span>) -&gt;</span> IO <span class="hljs-function"><span class="hljs-title">a</span> -&gt;</span> IO b
</code></pre>
<p>Làm thế nào để làm việc đó. À, <em>IO a</em> là một công thức có tác dụng phụ
và tạo ra <em>a</em> . Vì vậy, làm thế nào để chúng ta có được một <em>b</em> trong số
đó? Chúng tôi thực hiện công thức, nhưng, trước khi trả về a , chúng tôi
áp dụng hàm <em>(a -> b)</em> cho <em>a</em> và trả về kết quả là <em>b</em> .</p>
<p>Trong REPL, chúng ta hãy xem xét hàm <em>toUpper</em> .</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; <span class="hljs-keyword">import</span> <span class="hljs-keyword">Data</span>.<span class="hljs-built_in">Char</span>
Prelude <span class="hljs-keyword">Data</span>.<span class="hljs-built_in">Char</span> Week04.Contract&gt; :t toUpper
toUpper :: <span class="hljs-built_in">Char</span> -&gt; <span class="hljs-built_in">Char</span>
Prelude <span class="hljs-keyword">Data</span>.<span class="hljs-built_in">Char</span> Week04.Contract&gt; toUpper <span class="hljs-string">'q'</span>
<span class="hljs-string">'Q'</span>
</code></pre>
<p>Nếu chúng ta muốn áp dụng được cho một chuỗi chứ không phải là một Char
chúng ta có thể sử dụng bản đồ chức năng. Các chuỗi <em>String</em>s trong
Haskell chỉ là <em>Char</em>s .</p>
<pre><code class="lang-{.haskell}"><span class="hljs-symbol">Prelude</span> <span class="hljs-meta">Data</span>.Char Week04.Contract&gt; <span class="hljs-meta">map</span> toUpper <span class="hljs-string">"Haskell"</span>
<span class="hljs-string">"HASKELL"</span>
</code></pre>
<p>Hàm <em>map toUpper</em> là một hàm chuyển từ <em>String</em> to <em>String</em>.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-selector-tag">Prelude</span> <span class="hljs-selector-tag">Data</span><span class="hljs-selector-class">.Char</span> <span class="hljs-selector-tag">Week04</span><span class="hljs-selector-class">.Contract</span>&gt; <span class="hljs-selector-pseudo">:t</span> <span class="hljs-selector-tag">map</span> <span class="hljs-selector-tag">toUpper</span>
<span class="hljs-selector-tag">map</span> <span class="hljs-selector-tag">toUpper</span> :: <span class="hljs-selector-attr">[Char]</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-attr">[Char]</span>
</code></pre>
<p>Và chúng ta có thể sử dụng kết hợp với <em>fmap</em>. Nếu chúng ta sử dụng <em>map
toUpper</em> làm chức năng chuyển đổi <em>a</em> thành <em>b</em> , chúng ta có thể thấy
loại đầu ra của fmap sẽ như thế nào khi áp dụng cho <em>IO a</em> .</p>
<pre><code class="lang-{.haskell}"><span class="hljs-selector-tag">Prelude</span> <span class="hljs-selector-tag">Data</span><span class="hljs-selector-class">.Char</span> <span class="hljs-selector-tag">Week04</span><span class="hljs-selector-class">.Contract</span>&gt; <span class="hljs-selector-pseudo">:t</span> <span class="hljs-selector-tag">fmap</span> (<span class="hljs-selector-tag">map</span> <span class="hljs-selector-tag">toUpper</span>) <span class="hljs-selector-tag">getLine</span>
<span class="hljs-selector-tag">fmap</span> (<span class="hljs-selector-tag">map</span> <span class="hljs-selector-tag">toUpper</span>) <span class="hljs-selector-tag">getLine</span> :: <span class="hljs-selector-tag">IO</span> <span class="hljs-selector-attr">[Char]</span>
</code></pre>
<p>Hãy xem nó trong hành động.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-symbol">Prelude</span> <span class="hljs-meta">Data</span>.Char Week04.Contract&gt; fmap (<span class="hljs-meta">map</span> toUpper) getLine
<span class="hljs-symbol">haskell</span>
<span class="hljs-string">"HASKELL"</span>
</code></pre>
<p>Chúng ta cũng có thể sử dụng toán tử <em>>></em> . Điều này chuỗi hai hành
động <em>IO</em> lại với nhau, bỏ qua kết quả của hành động đầu tiên. Trong ví
dụ sau, cả hai hành động sẽ được thực hiện theo trình tự.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; putStrLn <span class="hljs-string">"Hello"</span> <span class="hljs-meta">&gt;&gt; </span>putStrLn <span class="hljs-string">"World"</span>
Hello
World
</code></pre>
<p>Here, there is no result from <em>putStrLn</em>, but if there were, it would
have been ignored. Its side effects would have been performed, its
result ignored, then the second <em>putStrLn</em> side effects would been
performed before returning the result of the second call.</p>
<p>Then, there is an important operator that does not ignore the result of
the first <em>IO</em> action, and that is called <em>bind</em>. It is written as the
<em>>>=</em> symbol.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; :t (&gt;&gt;=)
(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p>We see the <em>Monad</em> constraint, but we can ignore that for now and just
think of <em>IO</em>.</p>
<p>What this says is that if I have a recipe that performs side effects
then gives me a result <em>a</em>, and given that I have a function that takes
an <em>a</em> and gives me back a recipe that returns a <em>b</em>, then I can combine
the recipe <em>m a</em> with the recipe <em>m b</em> by taking the value <em>a</em> and using
it in the recipe that results in the value <em>b</em>.</p>
<p>An example will make this clear.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; getLine <span class="hljs-meta">&gt;&gt;= </span>putStrLn
Haskell
Haskell
</code></pre>
<p>Here, the function <em>getLine</em> is of type <em>IO String</em>. The return value
<em>a</em> is passed to the function <em>(a -> m b)</em> which then generates a
recipe <em>putStrLn</em> with an input value of <em>a</em> and an output of type <em>IO
()</em>. Then, <em>putStrLn</em> performs its side effects and returns <em>Unit</em>.</p>
<p>There is another, very important, way to create <em>IO</em> actions, and that
is to create recipes that immediately return results without performing
any side effects.</p>
<p>That is done with a function called <em>return</em>.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; :t <span class="hljs-keyword">return</span>
<span class="hljs-keyword">return</span> :: Monad m =&gt; a -&gt; m a
</code></pre>
<p>Again, it is general for any Monad, we only need to think about <em>IO</em>
right now.</p>
<p>It takes a value <em>a</em> and returns a recipe that produces the value <em>a</em>.
In the case of <em>return</em>, the recipe does not actually create any side
effects.</p>
<p>For example:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; <span class="hljs-keyword">return</span> <span class="hljs-string">"Haskell"</span> <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> <span class="hljs-built_in">String</span>
<span class="hljs-string">"Haskell"</span>
</code></pre>
<p>We needed to specify the return type so that the REPL knows which Monad
we are using:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; :t <span class="hljs-keyword">return</span> <span class="hljs-string">"Haskell"</span> <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> <span class="hljs-built_in">String</span>
<span class="hljs-keyword">return</span> <span class="hljs-string">"Haskell"</span> <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> <span class="hljs-built_in">String</span> <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> <span class="hljs-built_in">String</span>

Prelude Week04.Contract&gt; :t <span class="hljs-keyword">return</span> <span class="hljs-string">"Haskell"</span>
<span class="hljs-keyword">return</span> <span class="hljs-string">"Haskell"</span> <span class="hljs-type">::</span> Monad m =&gt; m [<span class="hljs-built_in">Char</span>]
</code></pre>
<p>If we now go back to our <em>main</em> program, we can now write relatively
complex <em>IO</em> actions. For example, we can define an <em>IO</em> action that
will ask for two strings and print result of concatenating those two
strings to the console.</p>
<pre><code class="lang-{.haskell}">main :: IO ()
main = bar

bar :: IO ()
bar = getLine &gt;&gt;= \s -&gt;
      getLine &gt;&gt;= \t -&gt;
      putStrLn (s ++ t)
</code></pre>
<p>And then, when we run it, the program will wait for two inputs and then
output the concatenated result.</p>
<pre><code class="lang-{.bash}">cabal <span class="hljs-keyword">run</span><span class="bash"> hello
</span>one
two
onetwo
</code></pre>
<p>This is enough now for our purposes, although we won\&#39;t need the <em>IO</em>
Monad until perhaps later in the course when we talk about actually
deploying Plutus contracts. However, the <em>IO</em> Monad is an important
example, and a good one to start with.</p>
<p>So, for now, let\&#39;s completely forget about <em>IO</em> and just write pure,
functional Haskell, using the <em>Maybe</em> type.</p>
<h3 id="maybe">Maybe</h3>
<p>The <em>Maybe</em> type is one of the most useful types in Haskell.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt;<span class="hljs-keyword"> :i</span> Maybe
type Maybe<span class="hljs-keyword"> :</span>: * -&gt; *
data Maybe a = Nothing | Just a
   -- Defined in ‘GHC.Maybe’<span class="hljs-built_in">
instance </span>Applicative Maybe -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Eq a =&gt; Eq (Maybe a) -- Defined in ‘GHC.Maybe’<span class="hljs-built_in">
instance </span>Functor Maybe -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monad Maybe -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Semigroup a =&gt; Monoid (Maybe a) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Ord a =&gt; Ord (Maybe a) -- Defined in ‘GHC.Maybe’<span class="hljs-built_in">
instance </span>Semigroup a =&gt; Semigroup (Maybe a)
-- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Show a =&gt; Show (Maybe a) -- Defined in ‘GHC.Show’<span class="hljs-built_in">
instance </span>Read a =&gt; Read (Maybe a) -- Defined in ‘GHC.Read’<span class="hljs-built_in">
instance </span>Foldable Maybe -- Defined in ‘Data.Foldable’<span class="hljs-built_in">
instance </span>Traversable Maybe -- Defined in ‘Data.Traversable’<span class="hljs-built_in">
instance </span>MonadFail Maybe -- Defined in ‘Control.Monad.Fail’
</code></pre>
<p>It is often called something like <em>Optional</em> in other programming
languages.</p>
<p>It has two constructors - <em>Nothing</em>, which takes no arguments, and
<em>Just</em>, which takes one argument.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Maybe</span> a = <span class="hljs-type">Nothing</span> | <span class="hljs-type">Just</span> a</span>
</code></pre>
<p>Let\&#39;s look at an example.</p>
<p>In Haskell, if you want to pass a <em>String</em> to a value that has a <em>read</em>
instance, you will normally do this with the <em>read</em> function.</p>
<pre><code class="lang-{.haskell}">Week04.Maybe&gt; <span class="hljs-keyword">read</span> <span class="hljs-string">"42"</span> :: <span class="hljs-keyword">Int</span>
<span class="hljs-number">42</span>
</code></pre>
<p>But, <em>read</em> is a bit unpleasant, because if we have something that
can\&#39;t be parsed as an <em>Int</em>, then we get an error.</p>
<pre><code class="lang-{.haskell}">Week04.Maybe&gt; <span class="hljs-keyword">read</span> <span class="hljs-string">"42+u"</span> :: <span class="hljs-keyword">Int</span>
*** Exception: Prelude.<span class="hljs-keyword">read</span>: no parse
</code></pre>
<p>Let\&#39;s import <em>readMaybe</em> to do it in a better way.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-selector-tag">Prelude</span> <span class="hljs-selector-tag">Week04</span><span class="hljs-selector-class">.Maybe</span>&gt; <span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">Text</span><span class="hljs-selector-class">.Read</span> (<span class="hljs-selector-tag">readMaybe</span>)
<span class="hljs-selector-tag">Prelude</span> <span class="hljs-selector-tag">Text</span><span class="hljs-selector-class">.Read</span> <span class="hljs-selector-tag">Week04</span><span class="hljs-selector-class">.Contract</span>&gt;
</code></pre>
<p>The function <em>readMaybe</em> does the same as <em>read</em>, but it returns a
<em>Maybe</em>, and in the case where it cannot parse, it will return a <em>Maybe</em>
created with the <em>Nothing</em> constructor.</p>
<pre><code class="lang-{.haskell}">Prelude <span class="hljs-built_in">Text</span>.Read Week04.Contract&gt; readMaybe <span class="hljs-string">"42"</span> <span class="hljs-type">::</span> Maybe <span class="hljs-built_in">Int</span>
Just <span class="hljs-number">42</span>

Prelude <span class="hljs-built_in">Text</span>.Read Week04.Contract&gt; readMaybe <span class="hljs-string">"42+u"</span> <span class="hljs-type">::</span> Maybe <span class="hljs-built_in">Int</span>
<span class="hljs-built_in">Nothing</span>
</code></pre>
<p>Let\&#39;s say we want to create a new function that returns a <em>Maybe</em>.</p>
<pre><code>foo :: <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; Maybe Int
</code></pre><p>The idea is that the function should try to parse all three <em>String</em>s as
<em>Int</em>s. If all the <em>String</em>s can be successfully parsed as <em>Int</em>s, then
we want to add those three <em>Int</em>s to get a sum. If one of the parses
fails, we want to return <em>Nothing</em>.</p>
<p>One way to do that would be:</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">foo</span> :: String -&gt;</span> S<span class="hljs-function"><span class="hljs-title">tring</span> -&gt;</span> S<span class="hljs-function"><span class="hljs-title">tring</span> -&gt;</span> Maybe Int
foo x y z = case readMaybe x of
   N<span class="hljs-function"><span class="hljs-title">othing</span> -&gt;</span> Nothing
   J<span class="hljs-function"><span class="hljs-title">ust</span> k  -&gt;</span> case readMaybe y of
      N<span class="hljs-function"><span class="hljs-title">othing</span> -&gt;</span> Nothing
      J<span class="hljs-function"><span class="hljs-title">ust</span> l  -&gt;</span> case readMaybe z of
            N<span class="hljs-function"><span class="hljs-title">othing</span> -&gt;</span> Nothing
            J<span class="hljs-function"><span class="hljs-title">ust</span> m  -&gt;</span> Just (k + l + m)
</code></pre>
<p>Let\&#39;s see if it works. First, the case where is succeeds:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; :l Week04<span class="hljs-selector-class">.Maybe</span> 
Prelude Week04.Maybe&gt; foo <span class="hljs-string">"1"</span> <span class="hljs-string">"2"</span> <span class="hljs-string">"3"</span>
Just <span class="hljs-number">6</span>
</code></pre>
<p>But, if one of the values can\&#39;t be parsed, we get <em>Nothing</em>:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Maybe&gt; foo <span class="hljs-string">""</span> <span class="hljs-string">"2"</span> <span class="hljs-string">"3"</span>
<span class="hljs-built_in">Nothing</span>
</code></pre>
<p>The code is not ideal because we repeat the same pattern three times.
Each time we have to consider the two cases - whether the result of the
read is a <em>Just</em> or a <em>Nothing</em>.</p>
<p>Ask Haskellers, we hate repetition like this.</p>
<p>The thing we want to do is very simple. We want to pass the three
<em>String</em>s and add the result, but with all those cases it is very noisy
and very ugly. We want to abstract away this pattern.</p>
<p>One way to do that would be to define something like:</p>
<pre><code class="lang-{.haskell}"><span class="hljs-keyword">bindMaybe </span>:: Maybe a -&gt; (a -&gt; Maybe <span class="hljs-keyword">b) </span>-&gt; Maybe <span class="hljs-keyword">b
</span><span class="hljs-keyword">bindMaybe </span>Nothing = Nothing
<span class="hljs-keyword">bindMaybe </span>(<span class="hljs-keyword">Just </span>x) f = f x
</code></pre>
<p>Let\&#39;s write the same function again using <em>bindMaybe</em>.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">foo</span>' :: String -&gt;</span> S<span class="hljs-function"><span class="hljs-title">tring</span> -&gt;</span> S<span class="hljs-function"><span class="hljs-title">tring</span> -&gt;</span> Maybe Int
<span class="hljs-function"><span class="hljs-title">foo</span>' x y z = readMaybe x `bindMaybe` \k -&gt;</span>
            <span class="hljs-function"><span class="hljs-title">readMaybe</span> y `bindMaybe` \l -&gt;</span>
            <span class="hljs-function"><span class="hljs-title">readMaybe</span> z `bindMaybe` \m -&gt;</span>
            Just (k + l + m)
</code></pre>
<p>And then, in the REPL, we get the same results for <em>foo\&#39;</em> as we got for
<em>foo</em>.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Maybe&gt; foo <span class="hljs-string">"1"</span> <span class="hljs-string">"2"</span> <span class="hljs-string">"3"</span>
Just <span class="hljs-number">6</span>

Prelude Week04.Maybe&gt; foo <span class="hljs-string">""</span> <span class="hljs-string">"2"</span> <span class="hljs-string">"3"</span>
<span class="hljs-built_in">Nothing</span>
</code></pre>
<p>This does exactly the same as <em>foo</em>, but it is much more compact, there
is far less noise, and the business logic is much clearer.</p>
<p>It may, or may not, help to view the function with it not being used
with infix notation:</p>
<pre><code class="lang-{.haskell}">Prelude <span class="hljs-built_in">Text</span>.Read Week04.Maybe&gt; bindMaybe (readMaybe <span class="hljs-string">"42"</span> <span class="hljs-type">::</span> Maybe <span class="hljs-built_in">Int</span>) (\x -&gt; Just x)
Just <span class="hljs-number">42</span>
</code></pre>
<p>Here you can see the function clearly taking the <em>Maybe</em> and then the
function that takes the <em>a</em> from the <em>Maybe</em> and uses it as the input to
a function that returns a new <em>Maybe</em>.</p>
<p>This produces nothing useful, until we add the second <em>readMaybe</em></p>
<pre><code class="lang-{.haskell}">Prelude <span class="hljs-built_in">Text</span>.Read Week04.Maybe&gt; bindMaybe (readMaybe <span class="hljs-string">"42"</span> <span class="hljs-type">::</span> Maybe <span class="hljs-built_in">Int</span>) (\x -&gt; bindMaybe (readMaybe <span class="hljs-string">"5"</span> <span class="hljs-type">::</span> Maybe <span class="hljs-built_in">Int</span>) (\y -&gt; Just (y + x)))
Just <span class="hljs-number">47</span>
</code></pre>
<p>In some ways <em>Nothing</em> is a bit like an exception in other languages. If
any of the computations returns <em>Nothing</em>, the remainder of the
computations in the block are not performed and <em>Nothing</em> is returned.</p>
<h3 id="either">Either</h3>
<p>Another very useful type in Haskell is the <em>Either</em> type.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt;<span class="hljs-keyword"> :i</span> Either
type Either<span class="hljs-keyword"> :</span>: * -&gt; * -&gt; *
data Either a b = Left a | Right b
   -- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>Applicative (Either e) -- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>(Eq a, Eq b) =&gt; Eq (Either a b)
-- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>Functor (Either a) -- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>Monad (Either e) -- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>(Ord a, Ord b) =&gt; Ord (Either a b)
-- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>Semigroup (Either a b) -- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>(Show a, Show b) =&gt; Show (Either a b)
-- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>(Read a, Read b) =&gt; Read (Either a b)
-- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>Foldable (Either a) -- Defined in ‘Data.Foldable’<span class="hljs-built_in">
instance </span>Traversable (Either a) -- Defined in ‘Data.Traversable’
</code></pre>
<p><em>Either</em> takes two parameters, <em>a</em> and <em>b</em>. Like <em>Maybe</em> it has two
constructors, but unlike <em>Maybe</em> both take a value. It can <em>Either</em> be
an <em>a</em> or a <em>b</em>. The two constructors are <em>Left</em> and <em>Right</em>.</p>
<p>For example:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; <span class="hljs-built_in">Left</span> <span class="hljs-string">"Haskell"</span> :: Either <span class="hljs-built_in">String</span> <span class="hljs-built_in">Int</span>
<span class="hljs-built_in">Left</span> <span class="hljs-string">"Haskell"</span>
</code></pre>
<p>Or</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; <span class="hljs-built_in">Right</span> <span class="hljs-number">7</span> :: Either <span class="hljs-built_in">String</span> <span class="hljs-built_in">Int</span>
<span class="hljs-built_in">Right</span> <span class="hljs-number">7</span>
</code></pre>
<p>If we take the exception analogy a little further, then one issue with
<em>Maybe</em> is that if we return <em>Nothing</em>, there is no error message. But,
if we want something that gives a message, we can replace <em>Maybe</em> with
an <em>Either</em> type.</p>
<p>In that case, <em>Right</em> can correspond to <em>Just</em> and <em>Left</em> can correspond
to an error, as <em>Nothing</em> did. But, depending on what type we choose for
<em>a</em>, we can give appropriate error messages.</p>
<p>Let\&#39;s define something called <em>readEither</em> and see what it does when it
can and when it cannot parse its input.</p>
<pre><code class="lang-{.haskell}">readEither :: Read a =&gt; String -&gt; Either String a
readEither s <span class="hljs-built_in">case</span> readMaybe s of
   Nothing -&gt; <span class="hljs-keyword">Left</span> $ <span class="hljs-string">"can't parse: "</span> ++ s
   Just a  -&gt; <span class="hljs-keyword">Right</span> a
</code></pre>
<pre><code class="lang-{.haskell}">Prelude Week04.Either&gt; readEither <span class="hljs-string">"42"</span> <span class="hljs-type">::</span> Either <span class="hljs-built_in">String</span> <span class="hljs-built_in">Int</span>
Right <span class="hljs-number">42</span>
</code></pre>
<pre><code class="lang-{.haskell}">Prelude Week04.Either&gt; readEither <span class="hljs-string">"42+u"</span> <span class="hljs-type">::</span> Either <span class="hljs-built_in">String</span> <span class="hljs-built_in">Int</span>
Left <span class="hljs-string">"can't parse: 42+u"</span>
</code></pre>
<p>Using this, we can now rewrite <em>foo</em> in terms of <em>Either</em>. First, using
the long-winded method:</p>
<pre><code class="lang-{.haskell}">foo :: <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; Either <span class="hljs-built_in">String</span> <span class="hljs-built_in">Int</span>
foo x y z = <span class="hljs-keyword">case</span> readEither x of
   <span class="hljs-built_in">Left</span> <span class="hljs-built_in">err</span> -&gt; <span class="hljs-built_in">Left</span> <span class="hljs-built_in">err</span>
   <span class="hljs-built_in">Right</span> k  -&gt; <span class="hljs-keyword">case</span> readEither y of
      <span class="hljs-built_in">Left</span> <span class="hljs-built_in">err</span> -&gt; <span class="hljs-built_in">Left</span> <span class="hljs-built_in">err</span>
      <span class="hljs-built_in">Right</span> l  -&gt; <span class="hljs-keyword">case</span> readEither z of
            <span class="hljs-built_in">Left</span> <span class="hljs-built_in">err</span> -&gt; <span class="hljs-built_in">Left</span> <span class="hljs-built_in">err</span>
            <span class="hljs-built_in">Right</span> m  -&gt; <span class="hljs-built_in">Right</span> (k + l + m)
</code></pre>
<p>Let\&#39;s try it. First, the happy path:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Either&gt; foo <span class="hljs-string">"1"</span> <span class="hljs-string">"2"</span> <span class="hljs-string">"3"</span>
<span class="hljs-keyword">Right</span> <span class="hljs-number">6</span>
</code></pre>
<p>Then, when we have a problem:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Either&gt; foo <span class="hljs-string">"ays"</span> <span class="hljs-string">"2"</span> <span class="hljs-string">"3"</span>
<span class="hljs-keyword">Left</span> <span class="hljs-string">"can't parse: ays"</span>
</code></pre>
<p>But, we have the same problem that we had with <em>Maybe</em>; we have a lot of
repetition.</p>
<p>The solution is similar.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">bindEither</span> :: Either String a -&gt;</span> (<span class="hljs-function"><span class="hljs-title">a</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-title">ither</span> String b) -&gt;</span> Either String b
bindEither (Left err) _ = Left err
bindEither (Right x)  f = f x

<span class="hljs-function"><span class="hljs-title">foo</span>' :: String -&gt;</span> S<span class="hljs-function"><span class="hljs-title">tring</span> -&gt;</span> S<span class="hljs-function"><span class="hljs-title">tring</span> -&gt;</span> Either String Int
<span class="hljs-function"><span class="hljs-title">foo</span>' x y z = readEither x `bindEither` \k -&gt;</span>
            <span class="hljs-function"><span class="hljs-title">readEither</span> y `bindEither` \l -&gt;</span>
            <span class="hljs-function"><span class="hljs-title">readEither</span> z `bindEither` \m -&gt;</span>
            Right (k + l + m)
</code></pre>
<p>You can run this again in the REPL and it will behave in the same way as
its long-winded version.</p>
<h3 id="writer">Writer</h3>
<p>So far we have looked at three examples: <em>IO a</em>, <em>Maybe a</em> and <em>Either
String a</em>. <em>IO a</em> represents plans that can involve side effects and,
when executed, produce an <em>a</em>. <em>Maybe a</em> and <em>Either String a</em> represent
computations that can produce an <em>a</em> but can also fail. The difference
between <em>Maybe</em> and <em>Either</em> is just that <em>Maybe</em> does not produce any
error message, but <em>Either</em> does.</p>
<p>Now let\&#39;s look at a completely different example that captures the idea
of computations that can also produce log output.</p>
<p>We can represent that with a type.</p>
<pre><code class="lang-{.haskell}">data <span class="hljs-built_in">Writer</span> a = <span class="hljs-built_in">Writer</span> a [<span class="hljs-keyword">String</span>]
   deriving <span class="hljs-keyword">Show</span>
</code></pre>
<p>As an example, let\&#39;s write a function that returns a <em>Writer</em> for an
<em>Int</em> and writes a log message.</p>
<pre><code class="lang-{.haskell}">number <span class="hljs-symbol">:</span><span class="hljs-symbol">:</span> <span class="hljs-built_in">Int</span> -&gt; Writer <span class="hljs-built_in">Int</span>
number <span class="hljs-built_in">n</span> = Writer <span class="hljs-built_in">n</span> $ [<span class="hljs-string">"number: "</span> ++ show <span class="hljs-built_in">n</span>]
</code></pre>
<p>In the REPL:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.<span class="hljs-built_in">Writer</span>&gt; number <span class="hljs-number">42</span>
<span class="hljs-built_in">Writer</span> <span class="hljs-number">42</span> [<span class="hljs-string">"number: 42"</span>]
</code></pre>
<p>Now, let\&#39;s do something similar to that which we have done with <em>Maybe</em>
and <em>Either</em>.</p>
<p>Let\&#39;s write a function that takes three logging computations that each
produce an <em>Int</em> and we want to return a single computation that
produces the sum of those <em>Int</em>s.</p>
<pre><code class="lang-{.haskell}">foo :: <span class="hljs-built_in">Writer</span> Int -&gt; <span class="hljs-built_in">Writer</span> Int -&gt; <span class="hljs-built_in">Writer</span> Int -&gt; <span class="hljs-built_in">Writer</span> Int
foo (<span class="hljs-built_in">Writer</span> k xs) (<span class="hljs-built_in">Writer</span> l ys) (<span class="hljs-built_in">Writer</span> m zs) =
<span class="hljs-built_in">Writer</span> (K + l + m) $ xs ++ ys ++ zs
</code></pre>
<p>In the REPL:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Writer&gt; foo (number <span class="hljs-number">1</span>) (number <span class="hljs-number">2</span>) (number <span class="hljs-number">3</span>)
Writer <span class="hljs-number">6</span> [<span class="hljs-string">"number: 1"</span>,<span class="hljs-string">"number: 2"</span>,<span class="hljs-string">"number: 3"</span>]
</code></pre>
<p>Now, let\&#39;s write another useful function that takes a list of message
and producers a <em>Writer</em> with no useful result.</p>
<pre><code class="lang-{.haskell}">tell :: [<span class="hljs-keyword">String</span>] -&gt; <span class="hljs-built_in">Writer</span> ()
tell = <span class="hljs-built_in">Writer</span> ()
</code></pre>
<p>Now, we can update <em>foo</em> to add an extra log message showing the sum of
the numbers.</p>
<pre><code class="lang-{.haskell}">foo :: <span class="hljs-built_in">Writer</span> Int -&gt; <span class="hljs-built_in">Writer</span> Int -&gt; <span class="hljs-built_in">Writer</span> Int -&gt; <span class="hljs-built_in">Writer</span> Int
foo (<span class="hljs-built_in">Writer</span> k xs) (<span class="hljs-built_in">Writer</span> l ys) (<span class="hljs-built_in">Writer</span> m zs) =
<span class="hljs-keyword">let</span>
   s = k + l + m
   <span class="hljs-built_in">Writer</span> _ us = tell [<span class="hljs-string">"sum: "</span> ++ <span class="hljs-keyword">show</span> s]
in
   <span class="hljs-built_in">Writer</span> s $ xs ++ ys ++ zs ++ us
</code></pre>
<p>In the REPL:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Writer&gt; foo (number <span class="hljs-number">1</span>) (number <span class="hljs-number">2</span>) (number <span class="hljs-number">3</span>)
Writer <span class="hljs-number">6</span> [<span class="hljs-string">"number: 1"</span>,<span class="hljs-string">"number: 2"</span>,<span class="hljs-string">"number: 3"</span>,<span class="hljs-string">"sum: 6"</span>]
</code></pre>
<p>As before, we can write a bind function:</p>
<pre><code class="lang-{.haskell}">bindWriter :: Writer <span class="hljs-selector-tag">a</span> -&gt; (<span class="hljs-selector-tag">a</span> -&gt; Writer b) -&gt; Writer <span class="hljs-selector-tag">b</span>
bindWriter (Writer <span class="hljs-selector-tag">a</span> xs) f =
let
   Writer <span class="hljs-selector-tag">b</span> ys = f <span class="hljs-selector-tag">a</span>
<span class="hljs-keyword">in</span>
   Writer <span class="hljs-selector-tag">b</span> $ xs ++ ys
</code></pre>
<p>Here, the <em>bindWriter</em> function is returning the <em>Writer b</em> and
producing log messages which are a concatenation of the <em>xs</em> that we
pattern matched on input, and the <em>ys</em> that we pattern matched when
calling <em>f a</em> in order to produce the <em>Writer b</em>.</p>
<p>Now, we can rewrite <em>foo</em> using <em>bindWriter</em> and make it much nicer.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">foo</span>' :: Writer Int -&gt;</span> W<span class="hljs-function"><span class="hljs-title">riter</span> Int -&gt;</span> W<span class="hljs-function"><span class="hljs-title">riter</span> Int -&gt;</span> Writer Int
<span class="hljs-function"><span class="hljs-title">foo</span>' x y z = x `bindWriter` \k -&gt;</span>
            <span class="hljs-function"><span class="hljs-title">y</span> `bindWriter` \l -&gt;</span>
            <span class="hljs-function"><span class="hljs-title">z</span> `bindWriter` \m -&gt;</span>
            let s = k + l + m
            <span class="hljs-function"><span class="hljs-title">in</span> tell ["sum: " ++ show s] `bindWriter` \_ -&gt;</span>
               Writer s []
</code></pre>
<p>What we did with <em>foo</em> before, we can now do with <em>foo\&#39;</em>, and we get
the same result.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Writer&gt; foo' (number <span class="hljs-number">1</span>) (number <span class="hljs-number">2</span>) (number <span class="hljs-number">3</span>)
Writer <span class="hljs-number">6</span> [<span class="hljs-string">"number: 1"</span>,<span class="hljs-string">"number: 2"</span>,<span class="hljs-string">"number: 3"</span>,<span class="hljs-string">"sum: 6"</span>]
</code></pre>
<p>Admittedly, it is longer than it was before, but it is much nicer. We no
longer need to do the pattern matching to extract the messages. We
don\&#39;t have to explicitly combine the log messages, where we could make
a mistake and forget one, or get the order wrong. Instead, we abstract
all that away and can just concentrate on the business logic.</p>
<p>Although the pattern is the same as with <em>Maybe</em> and <em>Either</em>, note that
the special aspect of these computations is completely different. With
<em>Maybe</em> and <em>Either</em> we dealt with the notion of failure, whereas here,
with the <em>Writer</em>, there is no failure, but we instead have additional
output.</p>
<h3 id="what-is-a-monad-">What is a Monad?</h3>
<p>Now, we are in a position to explain what a Monad is.</p>
<p>Looking back at the four examples, what did they have in common? In all
four cases, We had a type constructor with one type parameter - <em>IO</em>,
<em>Maybe</em>, <em>Either String</em> and <em>Writer</em> all take a type parameter.</p>
<p>And, for all four of these examples, we had a bind function. For <em>IO</em>,
we had the <em>>>=</em> function and for the others we had the bind functions
that we wrote ourselves.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">bindWriter</span> :: Writer a -&gt;</span> (<span class="hljs-function"><span class="hljs-title">a</span> -&gt;</span> W<span class="hljs-function"><span class="hljs-title">riter</span> b) -&gt;</span> Writer b
<span class="hljs-function"><span class="hljs-title">bindEither</span> :: Either String a -&gt;</span> (<span class="hljs-function"><span class="hljs-title">a</span> -&gt;</span> E<span class="hljs-function"><span class="hljs-title">ither</span> String b) -&gt;</span> Either String b
<span class="hljs-function"><span class="hljs-title">bindMaybe</span> :: Maybe a -&gt;</span> (<span class="hljs-function"><span class="hljs-title">a</span> -&gt;</span> M<span class="hljs-function"><span class="hljs-title">aybe</span> b) -&gt;</span> Maybe b
</code></pre>
<p>How the bind works depends on the case. In the case of <em>IO</em> it is
built-in magic, but you can think of it as just combining the two plans
describing the actions to take during computation. For <em>bindMaybe</em> and
<em>bindEither</em> the logic is for the whole plan to fail if any part of it
fails, and for <em>bindWriter</em>, the logic was to combine the list of log
messages.</p>
<p>And that is the main idea of Monads. It\&#39;s a concept of computation with
some additional side effects, and the ability to bind two such
computations together.</p>
<p>There is another aspect that we briefly mentioned in the case of <em>IO</em>
but not for the other examples - another thing that we can always do.</p>
<p>Whenever we have such a concept of computation with side effects, we
also also always have the ability to produce a computation of this kind
that <em>doesn\&#39;t</em> have any side effects.</p>
<p>In the example of <em>IO</em>, this was done with <em>return</em>. Given an <em>a</em>, you
can create an <em>IO a</em> which is the recipe that always simply returns the
<em>a</em> with no side effects. Each of the other example has this ability as
well, as shown below.</p>
<pre><code class="lang-{.haskell}">return              :: <span class="hljs-selector-tag">a</span> -&gt; IO <span class="hljs-selector-tag">a</span>
Just                :: <span class="hljs-selector-tag">a</span> -&gt; Maybe <span class="hljs-selector-tag">a</span>
Right               :: <span class="hljs-selector-tag">a</span> -&gt; Either String <span class="hljs-selector-tag">a</span>
(\<span class="hljs-selector-tag">a</span> -&gt; Writer <span class="hljs-selector-tag">a</span> []) :: <span class="hljs-selector-tag">a</span> -&gt; Writer a
</code></pre>
<p>And it is the combination of these two features that defines a Monad.</p>
<ul>
<li>the ability to bind two computations together</li>
<li>the possibility to construct a computation from a pure value without
making use of any of the potential side effects</li>
</ul>
<p>If we look in the REPL:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt;<span class="hljs-keyword"> :i</span> Monad
type Monad<span class="hljs-keyword"> :</span>: (* -&gt; *) -&gt; Constraint
class Applicative m =&gt; Monad m where
(&gt;&gt;=)<span class="hljs-keyword"> :</span>: m a -&gt; (a -&gt; m b) -&gt; m b
(&gt;&gt;)<span class="hljs-keyword"> :</span>: m a -&gt; m b -&gt; m b<span class="hljs-built_in">
return </span>:: a -&gt; m a
{-<span class="hljs-comment"># MINIMAL (&gt;&gt;=) #-}</span>
   -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monad (Either e) -- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>Monad [] -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monad Maybe -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monad IO -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monad ((-&gt;) r) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>(Monoid a, Monoid b, Monoid c) =&gt; Monad ((,,,) a b c)
-- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>(Monoid a, Monoid b) =&gt; Monad ((,,) a b)
-- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monoid a =&gt; Monad ((,) a) -- Defined in ‘GHC.Base’
</code></pre>
<p>We see the bind function</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-params">(&gt;&gt;=)</span> :: <span class="hljs-title">m</span> <span class="hljs-title">a</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(a -&gt; m b)</span> -&gt;</span> m b
</code></pre>
<p>And the <em>return</em> function that takes a pure value and turns it into a
computation that has potential for side effects, but does not use them.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-literal">return</span> :: <span class="hljs-keyword">a</span> -&gt; m <span class="hljs-keyword">a</span>
</code></pre>
<p>The other function <em>>></em> can easily be defined in terms of <em>>>=</em>, but
is provided for convenience.</p>
<pre><code class="lang-{.haskell}">(&gt;&gt;) :: m <span class="hljs-selector-tag">a</span> -&gt; m <span class="hljs-selector-tag">b</span> -&gt; m b
</code></pre>
<p>What this function does is to throw away the result of the first
computation, so you could define it in terms of <em>>>=</em> by just ignoring
the argument to the function parameter.</p>
<p>There\&#39;s another technical computation. We see that <em>Monad</em> has the
super class <em>Applicative</em>, so every Monad is <em>Applicative</em>.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt;<span class="hljs-keyword"> :i</span> Applicative
type Applicative<span class="hljs-keyword"> :</span>: (* -&gt; *) -&gt; Constraint
class Functor f =&gt; Applicative f where
pure<span class="hljs-keyword"> :</span>: a -&gt; f a
(&lt;*&gt;)<span class="hljs-keyword"> :</span>: f (a -&gt; b) -&gt; f a -&gt; f b
GHC.Base.liftA2<span class="hljs-keyword"> :</span>: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
(*&gt;)<span class="hljs-keyword"> :</span>: f a -&gt; f b -&gt; f b
(&lt;*)<span class="hljs-keyword"> :</span>: f a -&gt; f b -&gt; f a
{-<span class="hljs-comment"># MINIMAL pure, ((&lt;*&gt;) | liftA2) #-}</span>
   -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Applicative (Either e) -- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>Applicative [] -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Applicative Maybe -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Applicative IO -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Applicative ((-&gt;) r) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>(Monoid a, Monoid b, Monoid c) =&gt;
         Applicative ((,,,) a b c)
-- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>(Monoid a, Monoid b) =&gt; Applicative ((,,) a b)
-- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monoid a =&gt; Applicative ((,) a) -- Defined in ‘GHC.Base’
</code></pre>
<p>We see it has a bunch of functions, but we only need the first two.</p>
<pre><code class="lang-{.haskell}">pure :: <span class="hljs-selector-tag">a</span> -&gt; f <span class="hljs-selector-tag">a</span>
(&lt;*&gt;) :: f (<span class="hljs-selector-tag">a</span> -&gt; b) -&gt; f <span class="hljs-selector-tag">a</span> -&gt; f b
</code></pre>
<p>The function <em>pure</em> has the same type signature as <em>return</em>. Then there
is \&lt;*> (pronounced \&#39;ap\&#39;) which looks a bit more complicated. But,
the truth is that, once you have <em>return</em> and <em>>>=</em> in a Monad, we can
easily define both <em>pure</em> and \&lt;*>.</p>
<p>We see that <em>Applicative</em> also has a superclass <em>Functor</em>.</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt;<span class="hljs-keyword"> :i</span> Functor
type Functor<span class="hljs-keyword"> :</span>: (* -&gt; *) -&gt; Constraint
class Functor f where
fmap<span class="hljs-keyword"> :</span>: (a -&gt; b) -&gt; f a -&gt; f b
(&lt;$)<span class="hljs-keyword"> :</span>: a -&gt; f b -&gt; f a
{-<span class="hljs-comment"># MINIMAL fmap #-}</span>
   -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor (Either a) -- Defined in ‘Data.Either’<span class="hljs-built_in">
instance </span>Functor [] -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor Maybe -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor IO -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor ((-&gt;) r) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor ((,,,) a b c) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor ((,,) a b) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Functor ((,) a) -- Defined in ‘GHC.Base’
</code></pre>
<p>As we mentioned in the context of <em>IO</em>, <em>Functor</em> has the <em>fmap</em>
function which, given a function from <em>a</em> to <em>b</em> will turn an <em>f a</em> into
an <em>f b</em>.</p>
<p>The prototypical example for <em>fmap</em> is lists where <em>fmap</em> is just <em>map</em>.
Given a function from <em>a</em> to <em>b</em>, you can create a list of type <em>b</em> from
a list of type <em>a</em> by applying the <em>map</em> function to each of the
elements of the list.</p>
<p>Again, once you have <em>return</em> and <em>>>=</em>, it is easy to define <em>fmap</em>.</p>
<p>So, whenever you want to define a Monad, you just define <em>return</em> and
<em>>>=</em>, and to make the compiler happy and to give instances for
<em>Functor</em> and <em>Applicative</em>, there\&#39;s always a standard way of doing it.</p>
<p>We can do this in the example of <em>Writer</em>.</p>
<pre><code class="lang-{.haskell}">import Control.Monad
<span class="hljs-built_in">
instance </span>Functor Writer where
   fmap = liftM
<span class="hljs-built_in">
instance </span>Applicative Writer where
   pure =<span class="hljs-built_in"> return
</span>   (&lt;*&gt;) = ap
<span class="hljs-built_in">
instance </span>Monad Writer where
  <span class="hljs-built_in"> return </span>a = Writer a []
   (&gt;&gt;=) = bindWriter
</code></pre>
<p>We don\&#39;t have to do the same for <em>Maybe</em>, <em>Either</em> or <em>IO</em> because they
are already Monads defined by the Prelude.</p>
<h3 id="why-is-this-useful-">Why Is This useful?</h3>
<p>It is always useful, in general, to identify a common pattern and give
it a name.</p>
<p>But, maybe the most important advantage is that there are lots of
functions that don\&#39;t care which Monad we are dealing with - they will
work with all Monads.</p>
<p>Let\&#39;s generalize the example where we compute the sum of three
integers. We use a <em>let</em> in the example below for reasons that will
become clear in moment.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">threeInts</span> :: Monad m =&gt; m Int -&gt;</span> <span class="hljs-function"><span class="hljs-title">m</span> Int -&gt;</span> <span class="hljs-function"><span class="hljs-title">m</span> Int -&gt;</span> m Int
threeInts mx my mz =
   <span class="hljs-function"><span class="hljs-title">mx</span> &gt;&gt;= \k -&gt;</span>
   <span class="hljs-function"><span class="hljs-title">my</span> &gt;&gt;= \l -&gt;</span>
   <span class="hljs-function"><span class="hljs-title">mz</span> &gt;&gt;= \m -&gt;</span>
   let s = k + l + m <span class="hljs-built_in">in</span> return s
</code></pre>
<p>Now we have this function, we can return to the <em>Maybe</em> example and
rewrite it.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">foo</span>'' :: String -&gt;</span> S<span class="hljs-function"><span class="hljs-title">tring</span> -&gt;</span> S<span class="hljs-function"><span class="hljs-title">tring</span> -&gt;</span> Maybe Int
foo<span class="hljs-string">''</span> x y z = threeInts (readMaybe x) (readMaybe y) (readMaybe z)
</code></pre>
<p>We can do the same for the <em>Either</em> example.</p>
<pre><code class="lang-{.haskell}">foo<span class="hljs-string">''</span> :: <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; Either <span class="hljs-built_in">String</span> <span class="hljs-built_in">Int</span>
foo<span class="hljs-string">''</span> x y z = threeInts (readEither x) (readEither y) (readEither z)
</code></pre>
<p>The <em>Writer</em> example is not exactly the same.</p>
<p>If we are happy not to have the log message for the sum, it is very
simple as it is already an instance of <em>threeInts</em>.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">foo</span>'' :: Writer Int -&gt;</span> W<span class="hljs-function"><span class="hljs-title">riter</span> Int -&gt;</span> W<span class="hljs-function"><span class="hljs-title">riter</span> Int -&gt;</span> Writer Int
foo<span class="hljs-string">''</span> x y z = threeInts
</code></pre>
<p>However, if we want the final log message, it becomes a little more
complicated.</p>
<pre><code class="lang-{.haskell}">foo<span class="hljs-string">''</span> :: Writer <span class="hljs-built_in">Int</span> -&gt; Writer <span class="hljs-built_in">Int</span> -&gt; Writer <span class="hljs-built_in">Int</span> -&gt; Writer <span class="hljs-built_in">Int</span>
foo<span class="hljs-string">''</span> x y z = <span class="hljs-keyword">do</span>
   s &lt;- threeInts x y z
   tell [<span class="hljs-string">"sum: "</span> ++ show s]
   <span class="hljs-keyword">return</span> s
</code></pre>
<p>If you look into the Control.Monad module in the standard Haskell
Prelude, you will see that there are many useful functions that you can
use for all Monads.</p>
<p>One way to think about a Monad is as a computation with a super power.</p>
<p>In the case of <em>IO</em>, the super power would be having real-world
side-effects. In the case of <em>Maybe</em>, the super power is being able to
fail. The super power of <em>Either</em> is to fail with an error message. And
in the case of <em>Writer</em>, the super power is to log messages.</p>
<p>There is a saying in the Haskell community that Haskell has an
overloaded semi-colon. The explanation for this is that in many
imperative programming languages, you have semi-colons that end with a
semi-colon - each statement is executed one after the other, each
separated by a semi-colon. But, what exactly the semi-colon means
depends on the language. For example, there could be an exception, in
which case computation would stop and wouldn\&#39;t continue with the next
lines.</p>
<p>In a sense, <em>bind</em> is like a semi-colon. And the cool thing about
Haskell is that it is a programmable semi-colon. We get to say what the
logic is for combining two computations together.</p>
<p>Each Monad comes with its own \&quot;semi-colon\&quot;.</p>
<h3 id="-do-notation">\&#39;do\&#39; notation</h3>
<p>Because this pattern is so common and monadic computations are all over
the place, there is a special notation for this in Haskell, called <em>do</em>
notation.</p>
<p>It is syntactic sugar. Let\&#39;s rewrite <em>threeInts</em> using <em>do</em> notation.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-title">threeInts'</span> :: <span class="hljs-type">Monad</span> m =&gt; m <span class="hljs-type">Int</span> -&gt; m <span class="hljs-type">Int</span> -&gt; m <span class="hljs-type">Int</span> -&gt; m <span class="hljs-type">Int</span>
<span class="hljs-title">threeInts'</span> mx my mz = <span class="hljs-keyword">do</span>
   k &lt;- mx
   l &lt;- my
   m &lt;- mz
   <span class="hljs-keyword">let</span> s = k + l + m
   return s
</code></pre>
<p>This does exactly the same thing as the non-<em>do</em> version, but it has
less noise.</p>
<p>Note that the <em>let</em> statement does not use an <em>in</em> part. It does not
need to inside a <em>do</em> block.</p>
<p>And that\&#39;s Monads. There is a lot more to say about them but hopefully
you now have an idea of what Monads are and how they work.</p>
<p>Often you are in a situation where you want several effects at once -for
example you may want optional failure <em>and</em> log messages. There are ways
to do that in Haskell. For example there are Monad Transformers where
one can basically build custom Monads with the features that you want.</p>
<p>There are other approaches. One is called Effect Systems, which has a
similar objective. And this is incidentally what Plutus uses for
important Monads. In particular the Contact Monad in the wallet, and the
Trace Monad which is used to test Plutus code.</p>
<p>The good news is that you don\&#39;t need to understand Effect Systems to
work with these Monads. You just need to know that you are working with
a Monad, and what super powers it has.</p>
<h2 id="plutus-monads">Plutus Monads</h2>
<p>Now that we have seen how to write monadic code, either by using bind
and return or by using do notation, we can look a very important Monad,
namely the Contract Monad, which you may have already noticed in
previous code examples.</p>
<p>The Contract Monad defines code that will run in the wallet, which is
the off-chain part of Plutus.</p>
<p>But, before we go into details, we will talk about a second Monad, the
EmulatorTrace monad.</p>
<h3 id="the-emulatortrace-monad">The EmulatorTrace Monad</h3>
<p>You may have wondered if there is a way to execute Plutus code for
testing purposes without using the Plutus Playground. There is indeed,
and this is done using the <em>EmulatorTrace</em> Monad.</p>
<p>You can think of a program in this monad as what we do manually in the
<em>simulator</em> tab of the playground. That is, we define the initial
conditions, we define the actions such as which wallets invoke which
endpoints with which parameters and we define the waiting periods
between actions.</p>
<p>The relevant definitions are in the package <em>plutus-contract</em> in module
<em>Plutus.Trace.Emulator</em>.</p>
<pre><code class="lang-{.haskell}">module Plutus<span class="hljs-selector-class">.Trace</span><span class="hljs-selector-class">.Emulator</span>
</code></pre>
<p>The most basic function is called <em>runEmulatorTrace</em>.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-comment">-- | Run an emulator trace to completion, returning a tuple of the final state</span>
<span class="hljs-comment">-- of the emulator, the events, and any error, if any.</span>
runEmulatorTrace
    :: EmulatorConfig
    -&gt; EmulatorTrace ()
    -&gt; ([EmulatorEvent], Maybe EmulatorErr, EmulatorState)
runEmulatorTrace cfg trace =
    <span class="hljs-function"><span class="hljs-params">(\(xs :&gt; (y, z)) -&gt; (xs, y, z))</span>
    $ run
    $ runReader (<span class="hljs-params">(initialDist . _initialChainState)</span> cfg)
    $ foldEmulatorStreamM <span class="hljs-params">(generalize list)</span>
    $ runEmulatorStream cfg trace</span>
</code></pre>
<p>It gets something called an <em>EmulatorConfig</em> and an <em>EmulatorTrace ()</em>,
which is a pure computation where no real-world side effects are
involved. It is a pure function that executes the trace on an emulated
blockchain, and then gives a result as a list of <em>EmulatorEvent</em>s, maybe
an error, if there was one, and then finally the final <em>EmulatorState</em>.</p>
<p><em>EmulatorConfig</em> is defined in a different module in the same package:</p>
<pre><code class="lang-{.haskell}"><span class="hljs-keyword">module</span> Wallet.Emulator.Stream

data EmulatorConfig =
EmulatorConfig
    { _initialChainState      :: InitialChainState -- ^ State <span class="hljs-keyword">of</span> the blockchain at the beginning <span class="hljs-keyword">of</span> the simulation. Can be given <span class="hljs-keyword">as</span> a map <span class="hljs-keyword">of</span> funds <span class="hljs-keyword">to</span> wallets, <span class="hljs-keyword">or</span> <span class="hljs-keyword">as</span> a block <span class="hljs-keyword">of</span> transactions.
    } deriving (Eq, Show)

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">InitialChainState</span> </span>= Either InitialDistribution Block
</code></pre>
<p>We see it only has one field, which is of type <em>InitialChainState</em> and
it is either <em>InitialDistribution</em> or <em>Block</em>.</p>
<p><em>InitialDistribution</em> is defined in another module in the same package,
and it is a type synonym for a map of key value pairs of <em>Wallet</em>s to
<em>Value</em>s, as you would expect. <em>Value</em> can be either lovelace or native
tokens.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Plutus</span>.<span class="hljs-title">Contract</span>.<span class="hljs-title">Trace</span></span>

<span class="hljs-keyword">type</span> InitialDistribution = Map Wallet Value
</code></pre>
<p>In the same module, we see something called <em>defaultDist</em> which returns
a default distribution for all wallets. It does this by passing the 10
wallets defined by <em>allWallets</em> to <em>defaultDistFor</em> which takes a list
of wallets.</p>
<pre><code class="lang-{.haskell}">-- | The wallets used <span class="hljs-keyword">in</span> mockchain simulations by <span class="hljs-keyword">default</span>. There are
--   ten wallets because the emulator comes with ten private keys.
<span class="hljs-literal">all</span>Wallets :: [EM.Wallet]
<span class="hljs-literal">all</span>Wallets = EM.Wallet <span class="hljs-variable">&lt;$&gt;</span> [<span class="hljs-number">1</span> .. <span class="hljs-number">10</span>]

<span class="hljs-keyword">default</span>Dist :: InitialDistribution
<span class="hljs-keyword">default</span>Dist = <span class="hljs-keyword">default</span>DistFor <span class="hljs-literal">all</span>Wallets

<span class="hljs-keyword">default</span>DistFor :: [EM.Wallet] -&gt; InitialDistribution
<span class="hljs-keyword">default</span>DistFor wallets = Map.<span class="hljs-keyword">from</span>List $ zip wallets (repeat (Ada.lovelaceValueOf <span class="hljs-number">100</span>_000_000))
</code></pre>
<p>We can try this out in the REPL:</p>
<pre><code class="lang-{.haskell}">Prelude Week04.Contract&gt; import Plutus.<span class="hljs-keyword">Trace</span>.Emulator
Prelude Plutus.<span class="hljs-keyword">Trace</span>.Emulator Week04.Contract&gt; import Plutus.Contract.<span class="hljs-keyword">Trace</span>
Prelude Plutus.<span class="hljs-keyword">Trace</span>.Emulator Plutus.Contract.<span class="hljs-keyword">Trace</span> Week04.Contract&gt; defaultDist
fromList [(Wallet <span class="hljs-number">1</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">2</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">3</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">4</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">5</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">6</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">7</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">8</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">9</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">10</span>,<span class="hljs-keyword">Value</span> (<span class="hljs-keyword">Map</span> [(,<span class="hljs-keyword">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])]))]
</code></pre>
<p>We can see that each of the 10 wallets has been given an initial
distribution of 100,000,000 lovelace.</p>
<p>We can also get the balances for a specific wallet or wallets:</p>
<pre><code class="lang-{.haskell}"><span class="hljs-selector-tag">Prelude</span> <span class="hljs-selector-tag">Plutus</span><span class="hljs-selector-class">.Trace</span><span class="hljs-selector-class">.Emulator</span> <span class="hljs-selector-tag">Plutus</span><span class="hljs-selector-class">.Contract</span><span class="hljs-selector-class">.Trace</span> <span class="hljs-selector-tag">Week04</span><span class="hljs-selector-class">.Contract</span>&gt; <span class="hljs-selector-tag">defaultDistFor</span> <span class="hljs-selector-attr">[Wallet 1]</span>
<span class="hljs-selector-tag">fromList</span> <span class="hljs-selector-attr">[(Wallet 1,Value (Map [(,Map [("",100000000)]</span>)]))]
</code></pre>
<p>If you want different initial values, of if you want native tokens, then
you have to specify that manually.</p>
<p>Let\&#39;s see what we need to run our first trace:</p>
<pre><code class="lang-{.haskell}">Prelude Plutus<span class="hljs-selector-class">.Trace</span><span class="hljs-selector-class">.Emulator</span> Plutus<span class="hljs-selector-class">.Contract</span><span class="hljs-selector-class">.Trace</span> Week04.Contract&gt; :t runEmulatorTrace
runEmulatorTrace
:: EmulatorConfig
-&gt; EmulatorTrace ()
-&gt; ([Wallet<span class="hljs-selector-class">.Emulator</span><span class="hljs-selector-class">.MultiAgent</span><span class="hljs-selector-class">.EmulatorEvent</span>], Maybe EmulatorErr,
      Wallet<span class="hljs-selector-class">.Emulator</span><span class="hljs-selector-class">.MultiAgent</span><span class="hljs-selector-class">.EmulatorState</span>)
</code></pre>
<p>So, we need an <em>EmulatorConfig</em> which we know takes an
<em>InitialChainState</em>.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-type">Prelude</span> <span class="hljs-type">Plutus</span>.<span class="hljs-type">Trace</span>.<span class="hljs-type">Emulator</span> <span class="hljs-type">Plutus</span>.<span class="hljs-type">Contract</span>.<span class="hljs-type">Trace</span> <span class="hljs-type">Week04</span>.<span class="hljs-type">Contract</span>&gt; <span class="hljs-keyword">import</span> Wallet.Emulator.Stream 
<span class="hljs-type">Prelude</span> <span class="hljs-type">Plutus</span>.<span class="hljs-type">Trace</span>.<span class="hljs-type">Emulator</span> <span class="hljs-type">Plutus</span>.<span class="hljs-type">Contract</span>.<span class="hljs-type">Trace</span> <span class="hljs-type">Wallet</span>.<span class="hljs-type">Emulator</span>.<span class="hljs-type">Stream</span> <span class="hljs-type">Week04</span>.<span class="hljs-type">Contract</span>&gt; :i <span class="hljs-type">InitialChainState</span> 
<span class="hljs-keyword">type</span> <span class="hljs-type">InitialChainState</span> :: *
<span class="hljs-keyword">type</span> <span class="hljs-type">InitialChainState</span> =
<span class="hljs-type">Either</span> <span class="hljs-type">InitialDistribution</span> <span class="hljs-type">Ledger</span>.<span class="hljs-type">Blockchain</span>.<span class="hljs-type">Block</span>
      <span class="hljs-comment">-- Defined in ‘Wallet.Emulator.Stream’</span>
</code></pre>
<p>If we take the <em>Left</em> of the <em>defaultDist</em> will will get an
<em>InitialDistribution</em>.</p>
<pre><code class="lang-{.haskell}">Prelude Plutus<span class="hljs-selector-class">.Trace</span><span class="hljs-selector-class">.Emulator</span> Plutus<span class="hljs-selector-class">.Contract</span><span class="hljs-selector-class">.Trace</span> Wallet<span class="hljs-selector-class">.Emulator</span><span class="hljs-selector-class">.Stream</span> Week04.Contract&gt; :t Left defaultDist
Left defaultDist :: Either InitialDistribution b
</code></pre>
<p>Which we can then use to construct an <em>EmulatorConfig</em>.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-symbol">Prelude</span> Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator.<span class="hljs-keyword">Stream </span>Week04.Contract&gt; EmulatorConfig $ Left defaultDist
<span class="hljs-symbol">EmulatorConfig</span> {_initialChainState = Left (fromList [(Wallet <span class="hljs-number">1</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">2</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">3</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">4</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">5</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">6</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">7</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">8</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">9</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])])),(Wallet <span class="hljs-number">10</span>,Value (<span class="hljs-meta">Map</span> [(,<span class="hljs-meta">Map</span> [(<span class="hljs-string">""</span>,<span class="hljs-number">100000000</span>)])]))])}
</code></pre>
<p>So, let\&#39;s try out <em>runEmulatorTrace</em>. Recall that, as well as and
<em>EmulatorConfig</em>, we also need to pass in an <em>EmulatorTrace</em>, and the
most simple one we can create is simply one that returns Unit - <em>return
()</em>.</p>
<pre><code class="lang-{.haskell}">runEmulatorTrace (EmulatorConfig <span class="hljs-variable">$ </span>Left defaultDist) <span class="hljs-variable">$ </span><span class="hljs-keyword">return</span> ()
</code></pre>
<p>If you run this in the REPL you will get a crazy amount of data output
to the console, even though we are not doing anything with the trace. If
you want to make it useful, you must somehow filter all this data down
to something that sensible, and aggregate it in some way.</p>
<p>Luckily, there are other functions as well as <em>runEmulatorTrace</em>. One of
them is <em>runEmulatorTraceIo</em> which runs the emulation then outputs the
trace in a nice form on the screen.</p>
<pre><code class="lang-{.haskell}">runEmulatorTraceIO
:: EmulatorTrace <span class="hljs-function"><span class="hljs-params">()</span>
-&gt;</span> IO ()
runEmulatorTraceIO = runEmulatorTraceIO<span class="hljs-string">' def def</span>
</code></pre>
<p>To use this function, we don\&#39;t need to specify an <em>EmulatorConfig</em> like
we did before, because by default will will just use the default
distribution.</p>
<p>In the REPL:</p>
<pre><code class="lang-{.haskell}"><span class="hljs-function"><span class="hljs-title">Prelude</span></span>...&gt; runEmulatorTraceIO <span class="hljs-symbol">$</span> return ()
</code></pre>
<pre><code class="lang-{.}">Slot <span class="hljs-number">00000</span>: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8
Slot <span class="hljs-number">00000</span>: SlotAdd Slot <span class="hljs-number">1</span>
Slot <span class="hljs-number">00001</span>: SlotAdd Slot <span class="hljs-number">2</span>
Final balances
Wallet <span class="hljs-number">1</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">2</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">3</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">4</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">5</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">6</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">7</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">8</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">9</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">10</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
</code></pre>
<p>And we see a much more manageable, concise output. Nothing happens, but
we see the Genesis transaction and then the final balances for each
wallet.</p>
<p>If you want more control, there is also <em>runEmulatorTraceIO\&#39;</em>, which
does take an <em>EmulatorConfig</em>, so we could specify a different
distribution.</p>
<pre><code class="lang-{.haskell}">runEmulatorTraceIO'
:: TraceConfig
-&gt; EmulatorConfig
-&gt; EmulatorTrace ()
-&gt; IO ()
runEmulatorTraceIO' tcfg cfg trace
<span class="hljs-section">= runPrintEffect (outputHandle tcfg) $ runEmulatorTraceEff tcfg cfg trace</span>
</code></pre>
<p>It also takes a <em>TraceConfig</em>, which has two fields.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">TraceConfig</span> = <span class="hljs-type">TraceConfig</span></span>
{ showEvent    :: <span class="hljs-type">EmulatorEvent'</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">String</span>
<span class="hljs-comment">-- ^ Function to decide how to print the particular events.</span>
, outputHandle :: <span class="hljs-type">Handle</span>
<span class="hljs-comment">-- ^ Where to print the outputs to. Default: 'System.IO.stdout'</span>
}
</code></pre>
<p>The first field, <em>showEvent</em> is a function that specifies which
<em>EmulatorEvent</em>s are displayed and how they are displayed. It takes an
<em>EmulatorEvent</em> as an argument and can return <em>Nothing</em> it the event
should not be displayed, or a <em>Just</em> with a <em>String</em> showing how the
event will be displayed.</p>
<p>Here is the default <em>TraceConfig</em> used by <em>runEmulatorTraceIO</em>. We can
see that most events are ignored and that we only get output for some of
the events.</p>
<pre><code class="lang-{.haskell}">instance Default TraceConfig <span class="hljs-keyword">where</span>
def = TraceConfig
            { showEvent     = defaultShowEvent
            , outputHandle  = stdout
            }

defaultShowEvent :: EmulatorEvent' -&gt; Maybe String
defaultShowEvent = \<span class="hljs-built_in">case</span>
UserThreadEvent (UserLog msg)                                        -&gt; Just $ <span class="hljs-string">"*** USER LOG: "</span> &lt;&gt; msg
InstanceEvent (ContractInstanceLog (ContractLog (A.String msg)) <span class="hljs-keyword">_</span> <span class="hljs-keyword">_</span>) -&gt; Just $ <span class="hljs-string">"*** CONTRACT LOG: "</span> &lt;&gt; show msg
InstanceEvent (ContractInstanceLog (StoppedWithError err)       <span class="hljs-keyword">_</span> <span class="hljs-keyword">_</span>) -&gt; Just $ <span class="hljs-string">"*** CONTRACT STOPPED WITH ERROR: "</span> &lt;&gt; show err
InstanceEvent (ContractInstanceLog NoRequestsHandled            <span class="hljs-keyword">_</span> <span class="hljs-keyword">_</span>) -&gt; Nothing
InstanceEvent (ContractInstanceLog (HandledRequest <span class="hljs-keyword">_</span>)           <span class="hljs-keyword">_</span> <span class="hljs-keyword">_</span>) -&gt; Nothing
InstanceEvent (ContractInstanceLog (CurrentRequests <span class="hljs-keyword">_</span>)          <span class="hljs-keyword">_</span> <span class="hljs-keyword">_</span>) -&gt; Nothing
SchedulerEvent <span class="hljs-keyword">_</span>                                                     -&gt; Nothing
ChainIndexEvent <span class="hljs-keyword">_</span> <span class="hljs-keyword">_</span>                                                  -&gt; Nothing
WalletEvent <span class="hljs-keyword">_</span> <span class="hljs-keyword">_</span>                                                      -&gt; Nothing
ev                                                                   -&gt; Just . renderString . layoutPretty defaultLayoutOptions . pretty $ ev
</code></pre>
<p>The second field is a handle which defaults to <em>stdout</em>, but we could
also specify a file here.</p>
<p>Now let\&#39;s look at a more interesting trace, using the <em>Vesting</em>
contract from the last lecture.</p>
<p>First, we define a <em>Trace</em>.</p>
<pre><code class="lang-{.haskell}">myTrace :: EmulatorTrace ()
myTrace = do
<span class="hljs-selector-tag">h1</span> &lt;- activateContractWallet (Wallet <span class="hljs-number">1</span>) endpoints
<span class="hljs-selector-tag">h2</span> &lt;- activateContractWallet (Wallet <span class="hljs-number">2</span>) endpoints
callEndpoint @<span class="hljs-string">"give"</span> <span class="hljs-selector-tag">h1</span> $ GiveParams
      { gpBeneficiary = pubKeyHash $ walletPubKey $ Wallet <span class="hljs-number">2</span>
      , gpDeadline    = Slot <span class="hljs-number">20</span>
      , gpAmount      = <span class="hljs-number">1000</span>
      }
void $ waitUntilSlot <span class="hljs-number">20</span>
callEndpoint @<span class="hljs-string">"grab"</span> <span class="hljs-selector-tag">h2</span> ()
void $ waitNSlots <span class="hljs-number">1</span>
</code></pre>
<p>The first thing we have to do is to activate the wallets using the
monadic function <em>activateContractWallet</em>. We bind the result of this
function to <em>h1</em>, and then bind the result of a second call (for Wallet
2) to <em>h2</em>. Those two values - <em>h1</em> and <em>h2</em> are handles to their
respective wallets.</p>
<p>Next, we use <em>callEndpoint</em> to simulate Wallet 1 calling the <em>give</em>
endpoint, with the shown parameters. We then wait for 20 slots. The
function <em>waitUntilSlot</em> actually returns a value representing the slot
that was reached, but, as we are not interested in that value here, we
use <em>void</em> to ignore it. We then simulate the call to the <em>grab</em>
endpoint by Wallet 2.</p>
<p>Now, we can write a function to call <em>runEmulatorTraceIO</em> with out
<em>Trace</em>.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-keyword">test </span>:: IO ()
<span class="hljs-keyword">test </span>= runEmulatorTraceIO myTrace
</code></pre>
<p>And, we can then run this in the REPL:</p>
<pre><code class="lang-{.haskell}">Prelude Plutus<span class="hljs-selector-class">.Trace</span><span class="hljs-selector-class">.Emulator</span> Plutus<span class="hljs-selector-class">.Contract</span><span class="hljs-selector-class">.Trace</span> Wallet<span class="hljs-selector-class">.Emulator</span> Week04<span class="hljs-selector-class">.Trace</span> Wallet<span class="hljs-selector-class">.Emulator</span><span class="hljs-selector-class">.Stream</span> Week04.Contract&gt; test
</code></pre>
<pre><code class="lang-{.}"><span class="hljs-keyword">Slot</span> <span class="hljs-number">00000</span>: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00000</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00001</span>: <span class="hljs-number">00000000</span><span class="hljs-number">-0000</span><span class="hljs-number">-4000</span><span class="hljs-number">-8000</span><span class="hljs-number">-000000000000</span> {Contract instance for wallet 1}:
  Contract instance started
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00001</span>: <span class="hljs-number">00000000</span><span class="hljs-number">-0000</span><span class="hljs-number">-4000</span><span class="hljs-number">-8000</span><span class="hljs-number">-000000000001</span> {Contract instance for wallet 2}:
  Contract instance started
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00001</span>: <span class="hljs-number">00000000</span><span class="hljs-number">-0000</span><span class="hljs-number">-4000</span><span class="hljs-number">-8000</span><span class="hljs-number">-000000000000</span> {Contract instance for wallet 1}:
  Receive endpoint call: Object (fromList [(<span class="hljs-string">"tag"</span>,<span class="hljs-keyword">String</span> <span class="hljs-string">"give"</span>),(<span class="hljs-string">"value"</span>,Object (fromList [(<span class="hljs-string">"unEndpointValue"</span>,Object (fromList [(<span class="hljs-string">"gpAmount"</span>,<span class="hljs-keyword">Number</span> <span class="hljs-number">1000.0</span>),(<span class="hljs-string">"gpBeneficiary"</span>,Object (fromList [(<span class="hljs-string">"getPubKeyHash"</span>,<span class="hljs-keyword">String</span> <span class="hljs-string">"39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f"</span>)])),(<span class="hljs-string">"gpDeadline"</span>,Object (fromList [(<span class="hljs-string">"getSlot"</span>,<span class="hljs-keyword">Number</span> <span class="hljs-number">20.0</span>)]))]))]))])
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00001</span>: W1: TxSubmit: <span class="hljs-number">49</span>f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00001</span>: TxnValidate <span class="hljs-number">49</span>f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00001</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00002</span>: *** CONTRACT LOG: <span class="hljs-string">"made a gift of 1000 lovelace to 39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f with deadline Slot {getSlot = 20}"</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00002</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">3</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00003</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">4</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00004</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">5</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00005</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">6</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00006</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">7</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00007</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">8</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00008</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">9</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00009</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">10</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00010</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">11</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00011</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">12</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00012</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">13</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00013</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">14</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00014</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">15</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00015</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">16</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00016</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">17</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00017</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">18</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00018</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">19</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00019</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">20</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00020</span>: <span class="hljs-number">00000000</span><span class="hljs-number">-0000</span><span class="hljs-number">-4000</span><span class="hljs-number">-8000</span><span class="hljs-number">-000000000001</span> {Contract instance for wallet 2}:
  Receive endpoint call: Object (fromList [(<span class="hljs-string">"tag"</span>,<span class="hljs-keyword">String</span> <span class="hljs-string">"grab"</span>),(<span class="hljs-string">"value"</span>,Object (fromList [(<span class="hljs-string">"unEndpointValue"</span>,<span class="hljs-keyword">Array</span> [])]))])
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00020</span>: W2: TxSubmit: d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00020</span>: TxnValidate d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00020</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">21</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00021</span>: *** CONTRACT LOG: <span class="hljs-string">"collected gifts"</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00021</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">22</span>
Final balances
Wallet <span class="hljs-number">1</span>: 
    {, ""}: <span class="hljs-number">99998990</span>
Wallet <span class="hljs-number">2</span>: 
    {, ""}: <span class="hljs-number">100000990</span>
Wallet <span class="hljs-number">3</span>: 
    {, ""}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">4</span>: 
    {, ""}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">5</span>: 
    {, ""}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">6</span>: 
    {, ""}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">7</span>: 
    {, ""}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">8</span>: 
    {, ""}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">9</span>: 
    {, ""}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">10</span>: 
    {, ""}: <span class="hljs-number">100000000</span>
</code></pre>
<p>This output is very similar to the output we see in the playground. We
can see the Genesis transaction as well as both the <em>give</em> and <em>grab</em>
transactions from the <em>Trace</em>. We can also see some log output from the
contract itself, prefixed with <em>CONTRACT LOG</em>.</p>
<p>We can also log from inside the <em>Trace</em> monad. We could, for example,
lof the result of the final <em>waitNSlots</em> call:</p>
<pre><code class="lang-{.haskell}">myTrace :: EmulatorTrace ()
myTrace = do
...
...
s &lt;- waitNSlots <span class="hljs-number">1</span>
Extras.logInfo $ <span class="hljs-string">"reached slot "</span> ++ show s
</code></pre>
<p>We would then see this output when we run the emulation:</p>
<pre><code class="lang-{.}">...
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00020</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">21</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00021</span>: *** USER LOG: reached slot <span class="hljs-keyword">Slot</span> {getSlot = 21}
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00021</span>: *** CONTRACT LOG: <span class="hljs-string">"collected gifts"</span>
<span class="hljs-keyword">Slot</span> <span class="hljs-number">00021</span>: SlotAdd <span class="hljs-keyword">Slot</span> <span class="hljs-number">22</span>
...
</code></pre>
<p>Now let\&#39;s look at the Contract Monad.</p>
<h3 id="the-contract-monad">The Contract Monad</h3>
<p>The purpose of the Contract Monad is to define off-chain code that runs
in the wallet. It has four type parameters:</p>
<pre><code class="lang-{.haskell}"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Contract</span> w s e a = <span class="hljs-type">Contract</span> { <span class="hljs-title">unContract</span> :: <span class="hljs-type">Eff</span> (<span class="hljs-type">ContractEffs</span> <span class="hljs-title">w</span> <span class="hljs-title">s</span> <span class="hljs-title">e</span>) <span class="hljs-title">a</span> }</span>
      <span class="hljs-keyword">deriving</span> <span class="hljs-class"><span class="hljs-keyword">newtype</span> (<span class="hljs-type">Functor</span>, <span class="hljs-type">Applicative</span>, <span class="hljs-type">Monad</span>)</span>
</code></pre>
<p>The <em>a</em> is the same as in every Monad - it denotes the result type of
the computation.</p>
<p>We will go into the other three in more detail later but just briefly:</p>
<ul>
<li>w is like our Writer monad example, it allows us to write log
messages of type <em>w</em>.</li>
<li>s describes the blockchain capabilities, e.g. waiting for a slot,
submitting transactions, getting the wallet\&#39;s public key. It can
also contain specific endpoints.</li>
<li>e describes the type of error messages that this monad can throw.</li>
</ul>
<p>Let\&#39;s write an example.</p>
<pre><code class="lang-{.haskell}">myContract1 <span class="hljs-type">::</span> Contract () BlockchainActions <span class="hljs-built_in">Text</span> ()
myContract1 = Contract.logInfo <span class="hljs-meta">@String</span> <span class="hljs-string">"Hello from the contract!"</span>
</code></pre>
<p>Here, we pass a <em>Contract</em> constructed with <em>Unit</em> as the <em>w</em> type and
<em>BlockchainActions</em> as the second argument, <em>s</em>. This gives us access to
all the blockchain actions - the only thing we can\&#39;t do is to call
specific endpoints.</p>
<p>For <em>e</em> - the error message type, we use <em>Text</em>. <em>Text</em> is a Haskell
type which is like <em>String</em>, but it is much more efficient.</p>
<p>We don\&#39;t want a specific result, so we use <em>Unit</em> for the type <em>a</em>.</p>
<p>For the function body, we write a log message. We use <em>\@String</em>
because, we have imported the type <em>Data.Text</em> and we have used the
<em>OverloadedStrings</em> GHC compiler option, so the compiler needs to know
what type we are referencing - a <em>Text</em> or a <em>String</em>. We can use
<em>\@String</em> if we also use the compiler option <em>TypeApplications</em>.</p>
<p>Let\&#39;s now define a <em>Trace</em> that starts the contract in the wallet, and
a <em>test</em> function to run it.</p>
<pre><code class="lang-{.haskell}">myTrace1 :: EmulatorTrace ()
myTrace1 = <span class="hljs-keyword">void</span> $ activateContractWallet (Wallet 1) myContract1

test1 :: IO ()
test1 = runEmulatorTraceIO myTrace1
</code></pre>
<p>If we run this in the REPL, we will see our log message from the
contract.</p>
<p>``` {.Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract&gt; test1
Slot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8
Slot 00000: SlotAdd Slot 1
Slot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:
Contract instance started
Slot 00001: <em>*</em> CONTRACT LOG: \&quot;Hello from the contract!\&quot;
Slot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:
Contract instance stopped (no errors)
Slot 00001: SlotAdd Slot 2
Final balances
Wallet 1: 
{, \&quot;\&quot;}: 100000000
Wallet 2: 
{, \&quot;\&quot;}: 100000000
Wallet 3: 
{, \&quot;\&quot;}: 100000000
Wallet 4: 
{, \&quot;\&quot;}: 100000000
Wallet 5: 
{, \&quot;\&quot;}: 100000000
Wallet 6: 
{, \&quot;\&quot;}: 100000000
Wallet 7: 
{, \&quot;\&quot;}: 100000000
Wallet 8: 
{, \&quot;\&quot;}: 100000000
Wallet 9: 
{, \&quot;\&quot;}: 100000000
Wallet 10: 
{, \&quot;\&quot;}: 100000000}</p>
<pre><code>
Now, <span class="hljs-keyword">let</span>\<span class="hljs-symbol">'s</span> throw an <span class="hljs-keyword">exception</span>.

``` {.haskell}
myContract1 :: Contract () BlockchainActions Text ()
myContract1 = <span class="hljs-keyword">do</span>
<span class="hljs-keyword">void</span> $ Contract.throwError <span class="hljs-string">"BOOM!"</span>
Contract.logInfo @String <span class="hljs-string">"Hello from the contract!"</span>
</code></pre><p>Recall that we chose the type <em>Text</em> as the error message.</p>
<pre><code class="lang-{.}">Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract&gt; test1
Slot <span class="hljs-number">00000</span>: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8
Slot <span class="hljs-number">00000</span>: SlotAdd Slot <span class="hljs-number">1</span>
Slot <span class="hljs-number">00001</span>: <span class="hljs-number">00000000</span>-<span class="hljs-number">0000</span>-<span class="hljs-number">4000</span>-<span class="hljs-number">8000</span>-<span class="hljs-number">000000000000</span> {Contract instance for wallet <span class="hljs-number">1</span>}:
Contract <span class="hljs-keyword">instance</span> started
Slot <span class="hljs-number">00001</span>: *** CONTRACT STOPPED WITH ERROR: <span class="hljs-string">"\"</span>BOOM!\<span class="hljs-string">""</span>
Slot <span class="hljs-number">00001</span>: SlotAdd Slot <span class="hljs-number">2</span>
Final balances
Wallet <span class="hljs-number">1</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">2</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">3</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">4</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">5</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">6</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">7</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">8</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">9</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
Wallet <span class="hljs-number">10</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
</code></pre>
<p>Now, we don\&#39;t get the log message, but we do get told that the contract
stopped with an error and we see our exception message.</p>
<p>Another thing you can do is to handle exceptions. We will use the
<em>handleError</em> function from module <em>Plutus.Contract.Types</em>.</p>
<pre><code class="lang-{.haskell}">handleError ::
      forall w s e e' a.
      (e -&gt; <span class="hljs-type">Contract</span> w s e' a)
      -&gt; <span class="hljs-type">Contract</span> w s e a
      -&gt; <span class="hljs-type">Contract</span> w s e' a
handleError f (<span class="hljs-type">Contract</span> c) = <span class="hljs-type">Contract</span> c' <span class="hljs-keyword">where</span>
      c' = <span class="hljs-type">E</span>.handleError @e (raiseUnderN @<span class="hljs-string">'[E.Error e'</span>] c) (fmap unContract f)
</code></pre>
<p>The <em>handleError</em> function takes an error handler and a <em>Contract</em>
instance. The error handler takes an argument of type <em>e</em> from our
contract, and returns a new <em>Contract</em> with the same type parameters as
the first, but we can change the type of the <em>e</em> argument - the error
type, which is expressed in the return <em>Contract</em> argument list as
<em>e\&#39;</em>.</p>
<pre><code class="lang-{.haskell}">myContract2 :: Contract () BlockchainActions Void ()
myContract2 = Contract.handleError
      (\err -&gt; Contract.logError $ <span class="hljs-string">"Caught error: "</span> ++ unpack err)
      myContract1

myTrace2 :: EmulatorTrace ()
myTrace2 = <span class="hljs-keyword">void</span> $ activateContractWallet (Wallet 1) myContract2

test2 :: IO ()
test2 = runEmulatorTraceIO myTrace2
</code></pre>
<p>We use the type <em>Void</em> as the error type. <em>Void</em> is a type that can hold
no value, so, by using this type we are saying that there cannot be any
errors for this contract.</p>
<p>::: {.note}
::: {.title}
Note
:::</p>
<p>The function <em>unpack</em> is defined in the <em>Data.Text</em> module. It converts
a value of type <em>Text</em> to a value of type <em>String</em>.
:::</p>
<pre><code class="lang-{.}">Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract&gt; test2
Slot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8
Slot 00000: SlotAdd Slot 1
Slot 00001: 00000000-0000-4000-8000-000000000000 {Contract<span class="hljs-built_in"> instance </span>for wallet 1}:
Contract<span class="hljs-built_in"> instance </span>started
Slot 00001: *** CONTRACT LOG: <span class="hljs-string">"Caught error: BOOM!"</span>
Slot 00001: 00000000-0000-4000-8000-000000000000 {Contract<span class="hljs-built_in"> instance </span>for wallet 1}:
Contract<span class="hljs-built_in"> instance </span>stopped (no errors)
Slot 00001: SlotAdd Slot 2
Final balances
<span class="hljs-keyword">.</span>..
</code></pre>
<p>We no longer get the error message, but, instead we get a message from
the error handler showing the exception that was thrown by Contract1.
Note that we still do not get the message \&quot;Hello from the contract!\&quot;.
Contract 1 still stopped processing after its error, but there was no
overall contract error due to the exception being caught and handled.</p>
<p>Of course, exceptions can also happen even if they are not explicitly
thrown by your contract code. There are operations, such as submitting a
transaction where there are insufficient inputs to make a payment for an
output, where Plutus will throw an exception.</p>
<p>Next, let\&#39;s look at the <em>s</em> parameter, the second parameter to
<em>Contract</em>, that determines the available blockchain actions.</p>
<p>In the first two examples we just used the <em>BlockChainActions</em> type
which has all the standard functionality but without support for
specific endpoints. If we want support for specific endpoints, we must
use a different type.</p>
<p>The way that is usually done is by using a type synonym. The following
example will create a type synonym <em>MySchema</em> that has all the
capabilities of <em>BlockChainActions</em> but with the addition of being able
to call endpoint <em>foo</em> with an argument of type <em>Int</em>.</p>
<pre><code class="lang-{.haskell}"><span class="hljs-keyword">type</span> <span class="hljs-type">MySchema </span>= BlockchainActions .\/ Endpoint <span class="hljs-string">"foo"</span> Int
</code></pre>
<p>::: {.note}
::: {.title}
Note
:::</p>
<p>The operator <em>.\/</em> is a type operator - it operates on types, not
values. In order to use this we need to use the <em>TypeOperators</em> and
<em>DataKinds</em> compiler options.
:::</p>
<p>Now, we can use the <em>MySchema</em> type to define our contract.</p>
<pre><code class="lang-{.haskell}">myContract3 <span class="hljs-symbol">:</span><span class="hljs-symbol">:</span> Contract () MySchema <span class="hljs-built_in">Text</span> ()
myContract3 = do
      <span class="hljs-built_in">n</span> &lt;- endpoint @<span class="hljs-string">"foo"</span>
      Contract.logInfo <span class="hljs-built_in">n</span>
</code></pre>
<p>This contract will block until the endpoint <em>foo</em> is called with, in our
case, an <em>Int</em>. Then the value of the <em>Int</em> parameter will be bound to
<em>n</em>. Because of this, it is no longer enough for us to just activate the
contract to test it. Now, we must invoke the endpoint as well.</p>
<p>In order to do this, we now need to handle from
<em>activateContractWallet</em>, which we can then use to call the endpoint.</p>
<pre><code class="lang-{.haskell}">myTrace3 <span class="hljs-type">::</span> EmulatorTrace ()
myTrace3 = <span class="hljs-keyword">do</span>
      h &lt;- activateContractWallet (Wallet <span class="hljs-number">1</span>) myContract3
      callEndpoint @<span class="hljs-string">"foo"</span> h <span class="hljs-number">42</span>

test3 <span class="hljs-type">::</span> <span class="hljs-built_in">IO</span> ()
test3 = runEmulatorTraceIO myTrace3
</code></pre>
<p>Running this in the REPL:</p>
<pre><code class="lang-{.}">Prelude Plutus<span class="hljs-selector-class">.Trace</span><span class="hljs-selector-class">.Emulator</span> Plutus<span class="hljs-selector-class">.Contract</span><span class="hljs-selector-class">.Trace</span> Wallet<span class="hljs-selector-class">.Emulator</span> Week04<span class="hljs-selector-class">.Trace</span> Wallet<span class="hljs-selector-class">.Emulator</span><span class="hljs-selector-class">.Stream</span> Week04.Contract&gt; test3
Slot <span class="hljs-number">00000</span>: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8
...
Receive endpoint call: Object (fromList [(<span class="hljs-string">"tag"</span>,String <span class="hljs-string">"foo"</span>),(<span class="hljs-string">"value"</span>,Object (fromList [(<span class="hljs-string">"unEndpointValue"</span>,Number <span class="hljs-number">42.0</span>)]))])
Slot <span class="hljs-number">00001</span>: <span class="hljs-number">00000000</span>-<span class="hljs-number">0000</span>-<span class="hljs-number">4000</span>-<span class="hljs-number">8000</span>-<span class="hljs-number">000000000000</span> {Contract instance <span class="hljs-keyword">for</span> wallet <span class="hljs-number">1</span>}:
Contract log: Number <span class="hljs-number">42.0</span>
...
Final balances
...
Wallet <span class="hljs-number">10</span>: 
{, <span class="hljs-string">""</span>}: <span class="hljs-number">100000000</span>
</code></pre>
<p>Finally, let\&#39;s look at the first type parameter, the writer. The <em>w</em>
cannot be an arbitrary type, it must be an instance of the type class
<em>Monoid</em>.</p>
<pre><code class="lang-{.haskell}">Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract&gt;<span class="hljs-keyword"> :i</span> Monoid
type Monoid<span class="hljs-keyword"> :</span>: * -&gt; Constraint
class Semigroup a =&gt; Monoid a where
mempty<span class="hljs-keyword"> :</span>: a
mappend<span class="hljs-keyword"> :</span>: a -&gt; a -&gt; a
mconcat<span class="hljs-keyword"> :</span>: [a] -&gt; a
{-<span class="hljs-comment"># MINIMAL mempty #-}</span>
      -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monoid [a] -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monoid Ordering -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Semigroup a =&gt; Monoid (Maybe a) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monoid a =&gt; Monoid (IO a) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monoid b =&gt; Monoid (a -&gt; b) -- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>(Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =&gt;
      Monoid (a, b, c, d, e)
-- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>(Monoid a, Monoid b, Monoid c, Monoid d) =&gt;
      Monoid (a, b, c, d)
-- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>(Monoid a, Monoid b, Monoid c) =&gt; Monoid (a, b, c)
-- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>(Monoid a, Monoid b) =&gt; Monoid (a, b)
-- Defined in ‘GHC.Base’<span class="hljs-built_in">
instance </span>Monoid () -- Defined in ‘GHC.Base’
</code></pre>
<p>This is a very important and very common type class in Haskell. It
defines <em>mempty</em> and <em>mappend</em>.</p>
<p>The function <em>mempty</em> is like the neutral element, and <em>mappend</em>
combines two elements of this type to create a new element of the same
type.</p>
<p>The prime example of a <em>Monoid</em> is <em>List</em>, when <em>mempty</em> is the empty
list <em>[]</em>, and <em>mappend</em> is concatenation <em>++</em>.</p>
<p>For example:</p>
<pre><code class="lang-{.haskell}">Prelude&gt; mempty :: <span class="hljs-string">[Int]</span>
<span class="hljs-string">[]</span>
Prelude&gt; mappend <span class="hljs-string">[1, 2, 3 :: Int]</span> <span class="hljs-string">[4, 5, 6]</span>
<span class="hljs-string">[1,2,3,4,5,6]</span>
</code></pre>
<p>The are many, many other examples of the <em>Monoid</em> type, and we will see
other instances in this course.</p>
<p>But for now, let\&#39;s stick with lists and write our last example.</p>
<pre><code class="lang-{.haskell}">myContract4 :: Contract [Int] BlockchainActions Text ()
myContract4 = do
    void $ Contract<span class="hljs-selector-class">.waitNSlots</span> <span class="hljs-number">10</span>
    tell [<span class="hljs-number">1</span>]
    void $ Contract<span class="hljs-selector-class">.waitNSlots</span> <span class="hljs-number">10</span>
    tell [<span class="hljs-number">2</span>]
    void $ Contract<span class="hljs-selector-class">.waitNSlots</span> <span class="hljs-number">10</span>
</code></pre>
<p>Rather than using <em>Unit</em> as our <em>w</em> type, we are using <em>[Int]</em>. This
allows us to use the <em>tell</em> function as shown.</p>
<p>This now gives us access to those messages during the trace, using the
<em>observableState</em> function.</p>
<pre><code class="lang-{.haskell}">myTrace4 :: EmulatorTrace ()
myTrace4 = do
    h &lt;- activateContractWallet (Wallet <span class="hljs-number">1</span>) myContract4

    void $ Emulator<span class="hljs-selector-class">.waitNSlots</span> <span class="hljs-number">5</span>
    xs &lt;- observableState h
    Extras<span class="hljs-selector-class">.logInfo</span> $ show xs

    void $ Emulator<span class="hljs-selector-class">.waitNSlots</span> <span class="hljs-number">10</span>
    ys &lt;- observableState h
    Extras<span class="hljs-selector-class">.logInfo</span> $ show ys

    void $ Emulator<span class="hljs-selector-class">.waitNSlots</span> <span class="hljs-number">10</span>
    zs &lt;- observableState h
    Extras<span class="hljs-selector-class">.logInfo</span> $ show zs

test4 :: IO ()
test4 = runEmulatorTraceIO myTrace4
</code></pre>
<p>If we run this in the REPL, we can see the <em>USER LOG</em> messages created
using the <em>tell</em> function.</p>
<pre><code class="lang-{.}">Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract&gt; test4
Slot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8
Slot 00000: SlotAdd Slot 1
Slot 00001: 00000000-0000-4000-8000-000000000000 {Contract<span class="hljs-built_in"> instance </span>for wallet 1}:
  Contract<span class="hljs-built_in"> instance </span>started
Slot 00001: SlotAdd Slot 2
<span class="hljs-keyword">.</span>..
Slot 00005: SlotAdd Slot 6
Slot 00006: 00000000-0000-4000-8000-000000000000 {Contract<span class="hljs-built_in"> instance </span>for wallet 1}:
  Sending contract state to Thread 0
Slot 00006: SlotAdd Slot 7
Slot 00007: *** USER LOG: []
Slot 00007: SlotAdd Slot 8
<span class="hljs-keyword">.</span>..
Slot 00015: SlotAdd Slot 16
Slot 00016: 00000000-0000-4000-8000-000000000000 {Contract<span class="hljs-built_in"> instance </span>for wallet 1}:
  Sending contract state to Thread 0
Slot 00016: SlotAdd Slot 17
Slot 00017: *** USER LOG: [1]
Slot 00017: SlotAdd Slot 18
<span class="hljs-keyword">.</span>..
Slot 00025: SlotAdd Slot 26
Slot 00026: 00000000-0000-4000-8000-000000000000 {Contract<span class="hljs-built_in"> instance </span>for wallet 1}:
  Sending contract state to Thread 0
Slot 00026: SlotAdd Slot 27
Slot 00027: *** USER LOG: [1,2]
Final balances
Wallet 1: 
    {, <span class="hljs-string">""</span>}: 100000000
Wallet 2: 
    {, <span class="hljs-string">""</span>}: 100000000
<span class="hljs-keyword">.</span>..
Wallet 10: 
    {, <span class="hljs-string">""</span>}: 100000000
</code></pre>
<p>Using this mechanism, it is possible to pass information from the
contract running in the wallet to the outside world. Using endpoints we
can pass information into a contract. And using the <em>tell</em> mechanism we
can get information out of the wallet.</p>
